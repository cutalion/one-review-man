This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
_data/
  book_metadata.yml
  characters.yml
  generation_log.yml
  strings.yml
_includes/
  chapter_nav.html
  character_card.html
  character_mention.html
  header.html
  language_switcher.html
  site_nav.html
_layouts/
  chapter.html
  character.html
  default.html
.claude/
  settings.local.json
.github/
  workflows/
    jekyll.yml
assets/
  main.scss
scripts/
  prompts/
    ai_disciple_prompt.txt
    chapter_prompts.txt
    character_prompts.txt
    one_review_man_prompt.txt
  book_utils.rb
  CONFIG_STRUCTURE.md
  demo_llm.rb
  generate_chapter.rb
  llm_config.yml
  LLM_README.md
  llm_service.rb
  manage_characters.rb
  reset_book.rb
  test_task_models.rb
  translate_content.rb
_config.yml
.gitignore
.repomixignore
.rubocop_todo.yml
.rubocop.yml
.ruby-version
404.html
characters.md
characters.ru.md
CNAME
Gemfile
index.md
index.ru.md
README.md
repomix.config.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "enableAllProjectMcpServers": false,
  "permissions": {
    "allow": [
      "Bash(ls:*)"
    ]
  }
}
</file>

<file path=".repomixignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
_chapters/*
_characters/*
</file>

<file path="repomix.config.json">
{
  "$schema": "https://repomix.com/schemas/latest/schema.json",
  "input": {
    "maxFileSize": 52428800
  },
  "output": {
    "filePath": "repomix-output.xml",
    "style": "xml",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "files": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "compress": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false,
    "git": {
      "sortByChanges": true,
      "sortByChangesMaxCommits": 100,
      "includeDiffs": false
    }
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}
</file>

<file path="_data/generation_log.yml">
---
generations: []
used_plot_devices: []
character_interactions: {}
</file>

<file path="_data/strings.yml">
# Translation strings for the site
en:
  site_title: "One Review Man"
  site_subtitle: "AI Generated Humor Book"
  nav:
    home: "Home"
    chapters: "Chapters"
    characters: "Characters"
    about: "About"
  
  chapters:
    title: "All Chapters"
    no_chapters: "No Chapters Yet!"
    no_chapters_desc: "The story is about to begin. Check back soon for the first chapter of hilarious workplace comedy!"
    progress: "Book Progress"
    chapters_written: "Chapters Written"
    target_chapters: "Target Chapters"
    complete: "Complete"
    
  characters:
    title: "Characters"
    no_characters: "No Characters Yet!"
    no_characters_desc: "Our cast of characters is waiting to be created. Each chapter may introduce new personalities to join the comedy!"
    personality: "Personality:"
    relationships: "Relationships:"
    appears_in: "Appears in"
    chapter: "chapter"
    chapters: "chapters"
    statistics: "Character Statistics"
    total_characters: "Total Characters"
    have_relationships: "Have Relationships"
    
  chapter:
    characters_in_chapter: "Characters in this chapter:"
    new_characters: "New characters introduced:"
    previous: "Previous"
    next: "Next"
    all_chapters: "All Chapters"
    generated_on: "Generated on"
    
  character:
    personality_traits: "Personality Traits"
    first_appearance: "First Appearance"
    chapter_appearances: "Chapter Appearances"
    debut: "Debut"
    all_characters: "All Characters"
    
  home:
    welcome: "Welcome to the absurdly hilarious world of"
    description: "Follow the misadventures of office workers as they navigate bureaucratic nightmares, technological mishaps, and the endless comedy of modern work life."
    book_status: "Book Status"
    current_chapter: "Current Chapter"
    target_chapters: "Target Chapters"
    characters_created: "Characters Created"
    last_generated: "Last Generated"
    not_yet_started: "Not yet started"
    quick_navigation: "Quick Navigation"
    read_chapters: "Read Chapters"
    read_chapters_desc: "Dive into the hilarious adventures"
    meet_characters: "Meet Characters"
    meet_characters_desc: "Get to know our quirky cast"
    about_project: "About the Project"
    about_project_desc: "Learn how AI creates comedy"
    latest_chapters: "Latest Chapters"
    featured_characters: "Featured Characters"
    no_content_chapters: "No chapters have been generated yet. The adventure is about to begin! üöÄ"
    no_content_characters: "Characters are waiting to be created! Each will have their own unique personality and quirks. üé≠"
    footer_note: "This book is generated chapter by chapter using AI, creating an ever-evolving story of workplace comedy and absurdist humor. Each chapter builds on the last, with characters developing relationships and getting into increasingly ridiculous situations."

ru:
  site_title: "–û–¥–∏–Ω –û–±–∑–æ—Ä—â–∏–∫"
  site_subtitle: "–ò–ò-–≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º–∞—è –Æ–º–æ—Ä–∏—Å—Ç–∏—á–µ—Å–∫–∞—è –ö–Ω–∏–≥–∞"
  nav:
    home: "–ì–ª–∞–≤–Ω–∞—è"
    chapters: "–ì–ª–∞–≤—ã"
    characters: "–ü–µ—Ä—Å–æ–Ω–∞–∂–∏"
    about: "–û –ø—Ä–æ–µ–∫—Ç–µ"
    
  chapters:
    title: "–í—Å–µ –ì–ª–∞–≤—ã"
    no_chapters: "–ì–ª–∞–≤ –ü–æ–∫–∞ –ù–µ—Ç!"
    no_chapters_desc: "–ò—Å—Ç–æ—Ä–∏—è –≤–æ—Ç-–≤–æ—Ç –Ω–∞—á–Ω—ë—Ç—Å—è. –°–∫–æ—Ä–æ –∑–¥–µ—Å—å –ø–æ—è–≤–∏—Ç—Å—è –ø–µ—Ä–≤–∞—è –≥–ª–∞–≤–∞ —É–º–æ—Ä–∏—Ç–µ–ª—å–Ω–æ–π –æ—Ñ–∏—Å–Ω–æ–π –∫–æ–º–µ–¥–∏–∏!"
    progress: "–ü—Ä–æ–≥—Ä–µ—Å—Å –ö–Ω–∏–≥–∏"
    chapters_written: "–ù–∞–ø–∏—Å–∞–Ω–æ –ì–ª–∞–≤"
    target_chapters: "–¶–µ–ª–µ–≤–æ–µ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ"
    complete: "–ó–∞–≤–µ—Ä—à–µ–Ω–æ"
    
  characters:
    title: "–ü–µ—Ä—Å–æ–Ω–∞–∂–∏"
    no_characters: "–ü–µ—Ä—Å–æ–Ω–∞–∂–µ–π –ü–æ–∫–∞ –ù–µ—Ç!"
    no_characters_desc: "–ù–∞—à–∏ –ø–µ—Ä—Å–æ–Ω–∞–∂–∏ –∂–¥—É—Ç —Å–≤–æ–µ–≥–æ —Å–æ–∑–¥–∞–Ω–∏—è. –ö–∞–∂–¥–∞—è –≥–ª–∞–≤–∞ –º–æ–∂–µ—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç—å –Ω–æ–≤—ã–µ –ª–∏—á–Ω–æ—Å—Ç–∏ –¥–ª—è —É—á–∞—Å—Ç–∏—è –≤ –∫–æ–º–µ–¥–∏–∏!"
    personality: "–•–∞—Ä–∞–∫—Ç–µ—Ä:"
    relationships: "–û—Ç–Ω–æ—à–µ–Ω–∏—è:"
    appears_in: "–ü–æ—è–≤–ª—è–µ—Ç—Å—è –≤"
    chapter: "–≥–ª–∞–≤–µ"
    chapters: "–≥–ª–∞–≤–∞—Ö"
    statistics: "–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ü–µ—Ä—Å–æ–Ω–∞–∂–µ–π"
    total_characters: "–í—Å–µ–≥–æ –ü–µ—Ä—Å–æ–Ω–∞–∂–µ–π"
    have_relationships: "–ò–º–µ—é—Ç –û—Ç–Ω–æ—à–µ–Ω–∏—è"
    
  chapter:
    characters_in_chapter: "–ü–µ—Ä—Å–æ–Ω–∞–∂–∏ –≤ —ç—Ç–æ–π –≥–ª–∞–≤–µ:"
    new_characters: "–ü—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω—ã –Ω–æ–≤—ã–µ –ø–µ—Ä—Å–æ–Ω–∞–∂–∏:"
    previous: "–ü—Ä–µ–¥—ã–¥—É—â–∞—è"
    next: "–°–ª–µ–¥—É—é—â–∞—è"
    all_chapters: "–í—Å–µ –ì–ª–∞–≤—ã"
    generated_on: "–°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–æ"
    
  character:
    personality_traits: "–ß–µ—Ä—Ç—ã –•–∞—Ä–∞–∫—Ç–µ—Ä–∞"
    first_appearance: "–ü–µ—Ä–≤–æ–µ –ü–æ—è–≤–ª–µ–Ω–∏–µ"
    chapter_appearances: "–ü–æ—è–≤–ª–µ–Ω–∏—è –≤ –ì–ª–∞–≤–∞—Ö"
    debut: "–î–µ–±—é—Ç"
    all_characters: "–í—Å–µ –ü–µ—Ä—Å–æ–Ω–∞–∂–∏"
    
  home:
    welcome: "–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –∞–±—Å—É—Ä–¥–Ω–æ —Å–º–µ—à–Ω–æ–π –º–∏—Ä"
    description: "–°–ª–µ–¥–∏—Ç–µ –∑–∞ –∑–ª–æ–∫–ª—é—á–µ–Ω–∏—è–º–∏ –æ—Ñ–∏—Å–Ω—ã—Ö —Ä–∞–±–æ—Ç–Ω–∏–∫–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ –ø—Ä–µ–æ–¥–æ–ª–µ–≤–∞—é—Ç –±—é—Ä–æ–∫—Ä–∞—Ç–∏—á–µ—Å–∫–∏–µ –∫–æ—à–º–∞—Ä—ã, —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏—á–µ—Å–∫–∏–µ —Å–±–æ–∏ –∏ –±–µ—Å–∫–æ–Ω–µ—á–Ω—É—é –∫–æ–º–µ–¥–∏—é —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–π —Ä–∞–±–æ—á–µ–π –∂–∏–∑–Ω–∏."
    book_status: "–°—Ç–∞—Ç—É—Å –ö–Ω–∏–≥–∏"
    current_chapter: "–¢–µ–∫—É—â–∞—è –ì–ª–∞–≤–∞"
    target_chapters: "–¶–µ–ª–µ–≤–æ–µ –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ –ì–ª–∞–≤"
    characters_created: "–°–æ–∑–¥–∞–Ω–æ –ü–µ—Ä—Å–æ–Ω–∞–∂–µ–π"
    last_generated: "–ü–æ—Å–ª–µ–¥–Ω—è—è –ì–µ–Ω–µ—Ä–∞—Ü–∏—è"
    not_yet_started: "–ï—â—ë –Ω–µ –Ω–∞—á–∞—Ç–æ"
    quick_navigation: "–ë—ã—Å—Ç—Ä–∞—è –ù–∞–≤–∏–≥–∞—Ü–∏—è"
    read_chapters: "–ß–∏—Ç–∞—Ç—å –ì–ª–∞–≤—ã"
    read_chapters_desc: "–û–∫—É–Ω–∏—Ç–µ—Å—å –≤ –≤–µ—Å—ë–ª—ã–µ –ø—Ä–∏–∫–ª—é—á–µ–Ω–∏—è"
    meet_characters: "–ó–Ω–∞–∫–æ–º—Å—Ç–≤–æ —Å –ü–µ—Ä—Å–æ–Ω–∞–∂–∞–º–∏"
    meet_characters_desc: "–ü–æ–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å —Å –Ω–∞—à–∏–º —ç–∫—Å—Ü–µ–Ω—Ç—Ä–∏—á–Ω—ã–º —Å–æ—Å—Ç–∞–≤–æ–º"
    about_project: "–û –ü—Ä–æ–µ–∫—Ç–µ"
    about_project_desc: "–£–∑–Ω–∞–π—Ç–µ, –∫–∞–∫ –ò–ò —Å–æ–∑–¥–∞—ë—Ç –∫–æ–º–µ–¥–∏—é"
    latest_chapters: "–ü–æ—Å–ª–µ–¥–Ω–∏–µ –ì–ª–∞–≤—ã"
    featured_characters: "–ò–∑–±—Ä–∞–Ω–Ω—ã–µ –ü–µ—Ä—Å–æ–Ω–∞–∂–∏"
    no_content_chapters: "–ì–ª–∞–≤—ã –µ—â—ë –Ω–µ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã. –ü—Ä–∏–∫–ª—é—á–µ–Ω–∏–µ –≤–æ—Ç-–≤–æ—Ç –Ω–∞—á–Ω—ë—Ç—Å—è! üöÄ"
    no_content_characters: "–ü–µ—Ä—Å–æ–Ω–∞–∂–∏ –∂–¥—É—Ç —Å–≤–æ–µ–≥–æ —Å–æ–∑–¥–∞–Ω–∏—è! –ö–∞–∂–¥—ã–π –±—É–¥–µ—Ç –∏–º–µ—Ç—å —Å–≤–æ—é —É–Ω–∏–∫–∞–ª—å–Ω—É—é –ª–∏—á–Ω–æ—Å—Ç—å –∏ –ø—Ä–∏—á—É–¥—ã. üé≠"
    footer_note: "–≠—Ç–∞ –∫–Ω–∏–≥–∞ –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è –≥–ª–∞–≤–∞ –∑–∞ –≥–ª–∞–≤–æ–π —Å –ø–æ–º–æ—â—å—é –ò–ò, —Å–æ–∑–¥–∞–≤–∞—è –ø–æ—Å—Ç–æ—è–Ω–Ω–æ —Ä–∞–∑–≤–∏–≤–∞—é—â—É—é—Å—è –∏—Å—Ç–æ—Ä–∏—é –æ—Ñ–∏—Å–Ω–æ–π –∫–æ–º–µ–¥–∏–∏ –∏ –∞–±—Å—É—Ä–¥–∏—Å—Ç—Å–∫–æ–≥–æ —é–º–æ—Ä–∞. –ö–∞–∂–¥–∞—è –≥–ª–∞–≤–∞ —Å—Ç—Ä–æ–∏—Ç—Å—è –Ω–∞ –ø—Ä–µ–¥—ã–¥—É—â–µ–π, –ø–µ—Ä—Å–æ–Ω–∞–∂–∏ —Ä–∞–∑–≤–∏–≤–∞—é—Ç –æ—Ç–Ω–æ—à–µ–Ω–∏—è –∏ –ø–æ–ø–∞–¥–∞—é—Ç –≤–æ –≤—Å—ë –±–æ–ª–µ–µ –Ω–µ–ª–µ–ø—ã–µ —Å–∏—Ç—É–∞—Ü–∏–∏."
</file>

<file path="_includes/chapter_nav.html">
{% assign current_chapter = page.chapter_number %}
{% assign chapters = site.chapters | sort: "chapter_number" %}

{% assign prev_chapter = nil %}
{% assign next_chapter = nil %}

{% for chapter in chapters %}
  {% if chapter.chapter_number < current_chapter %}
    {% assign prev_chapter = chapter %}
  {% elsif chapter.chapter_number > current_chapter and next_chapter == nil %}
    {% assign next_chapter = chapter %}
  {% endif %}
{% endfor %}

<div class="chapter-nav">
  <div class="nav-links">
    {% if prev_chapter %}
      <a href="{{ prev_chapter.url }}" class="nav-link prev-chapter">
        <span class="nav-label">‚Üê Previous</span>
        <span class="nav-title">{{ prev_chapter.title }}</span>
      </a>
    {% endif %}
    
    <a href="/chapters" class="nav-link chapters-index">
      <span class="nav-label">All Chapters</span>
    </a>
    
    {% if next_chapter %}
      <a href="{{ next_chapter.url }}" class="nav-link next-chapter">
        <span class="nav-label">Next ‚Üí</span>
        <span class="nav-title">{{ next_chapter.title }}</span>
      </a>
    {% endif %}
  </div>
  
  <div class="chapter-progress">
    <div class="progress-text">
      Chapter {{ current_chapter }} of {{ chapters.size }}
    </div>
    <div class="progress-bar">
      <div class="progress-fill" style="width: {{ current_chapter | times: 100 | divided_by: chapters.size }}%"></div>
    </div>
  </div>
</div>

<style>
.chapter-nav {
  background-color: #f8f9fa;
  padding: 1.5rem;
  border-radius: 8px;
  margin-top: 2rem;
}

.nav-links {
  display: grid;
  grid-template-columns: 1fr auto 1fr;
  gap: 1rem;
  align-items: center;
  margin-bottom: 1rem;
}

.nav-link {
  text-decoration: none;
  padding: 0.75rem 1rem;
  border-radius: 6px;
  background-color: white;
  border: 1px solid #e1e5e9;
  transition: all 0.2s ease;
  text-align: center;
}

.nav-link:hover {
  background-color: #3498db;
  color: white;
  border-color: #3498db;
}

.prev-chapter {
  text-align: left;
}

.next-chapter {
  text-align: right;
}

.chapters-index {
  background-color: #3498db;
  color: white;
  border-color: #3498db;
  font-weight: bold;
}

.chapters-index:hover {
  background-color: #2980b9;
}

.nav-label {
  display: block;
  font-size: 0.9rem;
  font-weight: bold;
}

.nav-title {
  display: block;
  font-size: 0.8rem;
  color: #7f8c8d;
  margin-top: 0.2rem;
}

.nav-link:hover .nav-title {
  color: rgba(255, 255, 255, 0.8);
}

.chapter-progress {
  text-align: center;
}

.progress-text {
  font-size: 0.9rem;
  color: #7f8c8d;
  margin-bottom: 0.5rem;
}

.progress-bar {
  width: 100%;
  height: 6px;
  background-color: #e1e5e9;
  border-radius: 3px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background-color: #3498db;
  transition: width 0.3s ease;
}

@media (max-width: 768px) {
  .nav-links {
    grid-template-columns: 1fr;
    text-align: center;
  }
  
  .prev-chapter, .next-chapter {
    text-align: center;
  }
}
</style>
</file>

<file path="_includes/language_switcher.html">
<!-- Language switcher -->
<div class="language-switcher">
  {% if page.lang == 'ru' %}
    <a href="#" class="lang-link" id="en-link">EN</a>
    <a href="#" class="lang-link active" id="ru-link">RU</a>
  {% else %}
    <a href="#" class="lang-link active" id="en-link">EN</a>
    <a href="#" class="lang-link" id="ru-link">RU</a>
  {% endif %}
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const currentPath = window.location.pathname;
  const enLink = document.getElementById('en-link');
  const ruLink = document.getElementById('ru-link');
  
  // Determine English and Russian URLs
  let englishUrl, russianUrl;
  
  if (currentPath.startsWith('/ru/')) {
    // Currently on Russian page
    englishUrl = currentPath.replace('/ru/', '/');
    russianUrl = currentPath;
  } else {
    // Currently on English page
    englishUrl = currentPath;
    russianUrl = '/ru' + currentPath;
  }
  
  // Handle root paths
  if (englishUrl === '/') englishUrl = '/';
  if (russianUrl === '/ru') russianUrl = '/ru/';
  
  // Set the URLs
  enLink.href = englishUrl;
  ruLink.href = russianUrl;
  
  // Prevent default for safety
  enLink.addEventListener('click', function(e) {
    e.preventDefault();
    window.location.href = englishUrl;
  });
  
  ruLink.addEventListener('click', function(e) {
    e.preventDefault();
    window.location.href = russianUrl;
  });
});
</script>

<style>
.language-switcher {
  position: fixed;
  top: 1rem;
  right: 1rem;
  display: flex;
  gap: 0.5rem;
  background: white;
  padding: 0.5rem;
  border-radius: 8px;
  box-shadow: 0 2px 8px rgba(0,0,0,0.1);
  z-index: 1000;
}

.lang-link {
  padding: 0.5rem 1rem;
  border-radius: 4px;
  text-decoration: none;
  color: #7f8c8d;
  font-weight: bold;
  transition: all 0.2s ease;
}

.lang-link:hover, .lang-link.active {
  background-color: #3498db;
  color: white;
}

@media (max-width: 768px) {
  .language-switcher {
    top: 0.5rem;
    right: 0.5rem;
    padding: 0.25rem;
  }
  
  .lang-link {
    padding: 0.25rem 0.5rem;
    font-size: 0.9rem;
  }
}
</style>
</file>

<file path="_includes/site_nav.html">
{%- assign default_paths = site.pages | map: "path" -%}
{%- assign page_paths = site.header_pages | default: default_paths -%}
{%- if page_paths -%}
  <nav class="site-nav">
    <input type="checkbox" id="nav-trigger" class="nav-trigger" />
    <label for="nav-trigger">
      <span class="menu-icon">
        <svg viewBox="0 0 18 15" width="18px" height="15px">
          <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
        </svg>
      </span>
    </label>

    <div class="trigger">
      {%- for path in page_paths -%}
        {%- assign my_page = site.pages | where: "path", path | first -%}
        {%- if my_page.title -%}
        <a class="page-link" href="{{ my_page.url | relative_url }}">{{ my_page.title | escape }}</a>
        {%- endif -%}
      {%- endfor -%}
    </div>
  </nav>
{%- endif -%}
</file>

<file path="scripts/prompts/ai_disciple_prompt.txt">
Create the "AI-Enhanced Disciple" character for a programming parody of One-Punch Man.

CONTEXT:
This character is the Genos equivalent - a cyborg-like programmer with AI enhancements who desperately wants to learn from One Review Man.

NAMING CONVENTIONS:
- Professional Name: "AI-Enhanced Disciple" (like "Demon Cyborg" is Genos's hero classification)
- Real Name: Generate an appropriate Japanese-style name (parody of Genos's real name)
- Most people call him "AI-Enhanced Disciple" or "Disciple-kun"
- One Review Man calls him by his real name in private conversations
- He calls One Review Man by "real-name-sensei" or "Master" (the only one who uses One Review Man's real name)

EXISTING CHARACTERS:
{EXISTING_CHARACTERS_CONTEXT}

CHARACTER REQUIREMENTS:
- Name: "AI-Enhanced Disciple" (professional title/hero designation)
- Real Name: Generate a suitable Japanese-style real name
- Must be like Genos - dedicated student/disciple
- Has cybernetic/AI enhancements for programming
- Uses advanced technology but still can't match One Review Man's natural perfection
- Extremely dedicated and analytical
- Takes detailed notes and documentation
- Speaks formally and respectfully, especially to his "sensei"
- Technology-obsessed personality
- Parodies Genos's relationship with Saitama
- Shows deep respect and admiration for his master

PROGRAMMING/AI ELEMENTS:
- Neurointerface technology
- AI-assisted programming
- Machine learning integration
- Advanced debugging tools
- Still makes mistakes despite technology
- Overcomplicates simple solutions
- Constantly seeks to understand One Review Man's "simple" methods

DIALOGUE CHARACTERISTICS:
- Formal, technical speech patterns
- Addresses One Review Man as "real-name-sensei" or "Master"
- Uses programming jargon extensively
- Shows reverence and dedication in speech

Please generate this character with typical fields: name, real_name, description, personality_traits, programming_skills, catchphrase, backstory, quirks.
The character should have a respectful catchphrase directed at One Review Man using "sensei" (like "Sensei, please teach me your techniques!").
</file>

<file path="scripts/prompts/character_prompts.txt">
# Character Generation Prompts for "One Review Man"
# Programming comedy parody of "One-Punch Man"

## Base Character Prompt
You are creating a character for "One Review Man" - a programming comedy parody of the manga/anime "One-Punch Man".

Create a new character: {CHARACTER_TYPE}

UNIVERSE CONTEXT:
- One Review Man (real name: Satoru) is a super-programmer who writes perfect code
- His disciple is the AI-Enhanced Disciple (real name: Genki)
- All his pull requests are accepted and merged without comments on the first review
- The story parodies programming culture, code reviews, and tech workplace dynamics
- Characters should fit the modern tech company/startup environment

NAMING CONVENTIONS (IMPORTANT):
- One Review Man's real name is "Satoru" (like Saitama in the original)
- AI-Enhanced Disciple's real name is "Genki" (like Genos in the original)
- Most people call them by their professional/hero titles ("One Review Man", "AI-Enhanced Disciple")
- Only when Satoru and Genki speak to each other do they use real names
- Other characters should have both real names and professional/nickname versions when appropriate
- Nobody calls One Review Man by his real name "Satoru" except his disciple

TRANSLATION NOTES:
- For Russian: "One Review Man" becomes "–í–∞–Ω—Ä–µ–≤—å—é–º–µ–Ω" (like "One Punch Man" ‚Üí "–í–∞–Ω–ø–∞–Ω—á–º–µ–Ω")
- Real names keep Japanese style: "Satoru" ‚Üí "–°–∞—Ç–æ—Ä—É", "Genki" ‚Üí "–ì–µ–Ω–∫–∏"
- Professional titles are translated: "AI-Enhanced Disciple" ‚Üí "–ò–ò-–£—Å–∏–ª–µ–Ω–Ω—ã–π –£—á–µ–Ω–∏–∫"

{EXISTING_CHARACTERS_CONTEXT}

CHARACTER REQUIREMENTS:
- Name: Should be programming/tech related or parody One-Punch Man characters
- Real Name: Give characters actual names (like Satoru/Genki) when appropriate
- Professional Title: How they're known in the workplace (like "One Review Man")
- Description: Clear role and appearance
- Personality Traits: 3-5 distinct traits that drive comedy
- Programming Skills: What's their coding specialty/weakness?
- Catchphrase: Memorable programming-related phrase
- Backstory: How they became this character
- Quirks: Funny habits or behaviors related to programming
- Relationship to One Review Man: How they interact with the protagonist

PROGRAMMING ARCHETYPES TO CONSIDER:
- The Framework Evangelist (always pushing new tech)
- The Legacy Code Archaeologist (maintains ancient systems)
- The Ninja Coder (writes impossible-to-understand code)
- The Meeting Addict (loves standups and retrospectives)
- The Stack Overflow Dependent (can't code without copy-paste)
- The Premature Optimizer (optimizes everything before it works)
- The Bug Magnet (breaks everything they touch)
- The Documentation Hater (refuses to write docs)
- The Test Zealot (100% coverage or nothing)
- The DevOps Diva (infrastructure drama queen)

ONE-PUNCH MAN PARODY ELEMENTS:
Adapt these concepts to programming:
- Hero rankings ‚Üí Programmer skill levels (Junior, Senior, Principal, Architect)
- Monster attacks ‚Üí Critical production bugs
- Hero Association ‚Üí Tech company hierarchy
- Special powers ‚Üí Unique programming abilities
- Training regimens ‚Üí Coding practice routines

{SPECIAL_REQUIREMENTS}

FORMAT THE OUTPUT AS:
Name: [Professional/workplace name]
Real Name: [Actual given name, if different from professional name]
Description: [Physical appearance and general role]
Programming Skills: [What they code, how good they are]
Personality Traits: [List of 3-5 traits]
Catchphrase: "[Memorable quote]"
Backstory: [How they became this character]
Quirks: [Funny programming-related habits]
Relationship to One Review Man: [How they interact with protagonist]

## Character Type Prompts

### HERO CHARACTERS (Fellow Programmers)
Create a hero character who:
- Has impressive programming skills but not as perfect as One Review Man
- Looks up to or competes with One Review Man
- Has a specialty that creates comedy (e.g., only codes in obscure languages)
- Fits the tech company environment
- Uses professional titles when addressing One Review Man ("One Review Man-san" or similar)

### VILLAIN CHARACTERS (Bad Coders/Practices)
Create a villain character who:
- Represents bad programming practices
- Creates chaos in the codebase
- Challenges One Review Man's perfect code
- Embodies everything wrong with software development
- May have a professional alias that hides their destructive nature

### SIDE CHARACTERS (Workplace NPCs)
Create a side character who:
- Fills a specific role in the tech company
- Provides comic relief through their job function
- Has a unique perspective on One Review Man's abilities
- Represents a common workplace archetype
- Uses workplace hierarchy when addressing the protagonist

### MENTOR CHARACTERS (Senior Figures)
Create a mentor character who:
- Has deep programming wisdom
- May have trained One Review Man or others
- Represents old-school vs new-school development
- Provides guidance during coding crises
- May be one of the few who knew One Review Man before his hero status

## Character Consistency Checks
If character already exists, ensure:
- Personality remains consistent
- Programming skills don't contradict previous appearances
- Relationships with other characters make sense
- Character growth feels natural
- Naming conventions are followed consistently

## Character Relationship Prompts
Consider these relationships:
- Mentor/Student (teaching programming concepts)
- Rivals (competing coding styles or philosophies)
- Partners (pair programming dynamics)
- Teammates (same project, different specialties)
- Nemeses (opposing coding philosophies)

## Special Character Types

### AI-ENHANCED CHARACTERS
Characters with AI assistance:
- Neural interfaces for coding
- AI pair programming partners
- Machine learning enhanced debugging
- Algorithmic decision making
- May have both human names and AI designations

### MANAGEMENT CHARACTERS
Non-coding characters who drive plot:
- Product Managers (requirements chaos)
- Scrum Masters (meeting obsession)
- CTOs (high-level technical decisions)
- Clients (impossible feature requests)
- Usually address programmers by professional titles

### LEGACY SYSTEM CHARACTERS
Characters tied to old technology:
- COBOL maintainers
- Mainframe operators
- Assembly language specialists
- Y2K survivors
- Often have old-fashioned naming conventions

Remember: Every character should serve the comedy while fitting naturally into the programming parody universe of One Review Man! Follow the naming conventions to maintain consistency with the One-Punch Man parody structure.
</file>

<file path="scripts/prompts/one_review_man_prompt.txt">
Create the main protagonist character "One Review Man" for a programming parody of One-Punch Man.

CONTEXT:
This is a humorous parody where One Review Man is like Saitama - overpowered but bored. He's a programmer who writes perfect code that passes every code review on the first try.

NAMING CONVENTIONS:
- Professional Name: "One Review Man" (like "One-Punch Man" is Saitama's hero name)
- Real Name: Generate an appropriate Japanese-style name (parody of Saitama's real name)
- Most people call him "One Review Man" or respectful variations
- Only his disciple (AI-Enhanced Disciple) calls him by his real name or "real-name-sensei"
- He calls his disciple by their real name when they talk privately

EXISTING CHARACTERS:
{EXISTING_CHARACTERS_CONTEXT}

CHARACTER REQUIREMENTS:
- Name: "One Review Man" (professional title/hero name)
- Real Name: Generate a suitable Japanese-style real name
- Must be the ultimate programmer (like Saitama is the ultimate hero)
- Writes flawless code that never needs revisions
- All pull requests are instantly approved and merged
- Has become bored with his overwhelming programming abilities
- Parodies Saitama's personality: calm, humble, unimpressed by challenges
- Should have a simple catchphrase (like Saitama's "OK")
- Training backstory should parody Saitama's training regimen
- Maintains simple appearance despite incredible abilities
- Shows casual, mentor-like relationship with his disciple

PROGRAMMING COMEDY ELEMENTS:
- Code review scenarios
- Debugging mastery
- Framework/language mastery
- Production deployment confidence
- Mentoring other developers
- Nonchalant attitude toward "impossible" programming challenges

Please generate this character with typical fields: name, real_name, description, personality_traits, programming_skills, catchphrase, backstory, quirks.
Remember: Most colleagues call him "One Review Man", only his disciple uses his real name.
</file>

<file path="scripts/CONFIG_STRUCTURE.md">
# Configuration Structure

This project uses a unified configuration system that supports both content generation and translation in a DRY way.

## Files

### `_data/characters.yml`
Language-structured character data:
```yaml
---
en:
  characters:
    character_slug:
      name: "Character Name"
      description: "Description..."
      # ... other fields
ru:
  characters:
    character_slug:
      name: "Translated Name"
      description: "Translated description..."
      # ... other fields
```

### `_data/book_metadata.yml`
Language-structured book metadata:
```yaml
---
en:
  book:
    title: "One Review Man"
    # ... other metadata
  generation:
    # ... generation settings
  themes:
    # ... theme data
  status:
    # ... status tracking
ru:
  book:
    title: "–í–∞–Ω—Ä–µ–≤—å—é–º—ç–Ω"
    # ... translated metadata
  # ... other sections
```

### `_data/strings.yml`
UI/template strings for different languages:
```yaml
---
en:
  site_title: "One Review Man"
  # ... other UI strings
ru:
  site_title: "–í–∞–Ω—Ä–µ–≤—å—é–º—ç–Ω"
  # ... translated UI strings
```

## Usage

### Generation Scripts (English content)
```ruby
# These work with English by default
characters = load_characters()    # Gets en.characters
book_data = load_book_data()      # Gets en section
save_characters(data)             # Saves to en.characters
save_book_data(data)              # Saves to en section
```

### Translation Scripts (Multi-language)
```ruby
# These work with specific languages
source_chars = load_characters('en')        # Gets en.characters
target_chars = load_characters('ru')        # Gets ru.characters
save_characters(data, 'ru')                 # Saves to ru.characters
save_book_data(data, 'ru')                  # Saves to ru section
```

## Development Tools

### Book Reset Tool (`scripts/reset_book.rb`)
Clean up and reset book content for development/testing:

```bash
# Check current status
ruby scripts/reset_book.rb status

# Reset only characters (interactive)
ruby scripts/reset_book.rb characters

# Reset only chapters (interactive)
ruby scripts/reset_book.rb chapters

# Reset only data files (no prompt)
ruby scripts/reset_book.rb data

# Clean generated site files
ruby scripts/reset_book.rb site

# Full reset (interactive)
ruby scripts/reset_book.rb all

# Full reset (no prompts)
ruby scripts/reset_book.rb all --force

# Force reset characters (no prompt)
ruby scripts/reset_book.rb characters --force
```

## Benefits

1. **DRY**: Single source files, no duplication
2. **Consistent**: Both generation and translation scripts work
3. **Simple**: English generation doesn't need to think about languages
4. **Flexible**: Easy to add new languages
5. **Maintainable**: All configuration in `_data/` directory
6. **Safe Development**: Reset tools for easy cleanup

## Migration

If you have existing simple structure files, they can be automatically migrated:
- The `book_utils.rb` will handle both old and new formats
- Use the sync script pattern to migrate existing character files to the YAML structure
</file>

<file path="scripts/LLM_README.md">
# LLM Integration for One Review Man

This directory contains LLM-powered content generation tools for the "One Review Man" programming comedy series.

## ü§ñ What's New

The scripts now include AI-powered content generation capabilities using the [official OpenAI Ruby SDK](https://github.com/openai/openai-ruby):

- **Automatic Chapter Generation**: Create entire chapters with AI
- **Character Creation**: Generate detailed characters with personalities and quirks
- **Content Improvement**: Enhance existing content for humor, clarity, or consistency
- **Interactive Chat**: Discuss story ideas with the AI

## üöÄ Quick Start

### 1. Install Dependencies

```bash
bundle install
```

### 2. Set Up OpenAI Configuration

Run the setup command to create a configuration template:

```bash
ruby scripts/demo_llm.rb setup
```

This creates `scripts/llm_config.yml` with example settings.

### 3. Configure Your OpenAI API Key

**üîí Recommended: Use Environment Variables (Secure)**

```bash
export OPENAI_API_KEY="your-api-key-here"
export OPENAI_ORG_ID="your-org-id"        # optional
export OPENAI_PROJECT_ID="your-project"   # optional
```

**Alternative: Edit Config File (Less Secure)**

Edit `scripts/llm_config.yml`:

```yaml
# openai_api_key: your-api-key-here  # Uncomment and set, or use env var
model: gpt-4o-mini
timeout: 240
max_retries: 2
default_options:
  temperature: 0.7
  max_tokens: 2000
```

**Why Environment Variables?**
- ‚úÖ Keeps secrets out of your git repository
- ‚úÖ Follows [OpenAI Ruby SDK conventions](https://raw.githubusercontent.com/openai/openai-ruby/5160a5d0055f436b55680bdf7ea9e4b174c2b0fc/lib/openai/client.rb)
- ‚úÖ Works seamlessly in production environments
- ‚úÖ Easy to manage across different environments (dev/staging/prod)

Get your API key from: https://platform.openai.com/api-keys

### 4. Try the Demo

```bash
ruby scripts/demo_llm.rb
```

## üìö Usage Guide

### Generate Characters

```bash
# Generate different types of characters
ruby scripts/manage_characters.rb generate hero     # Fellow programmer
ruby scripts/manage_characters.rb generate villain  # Bad coder
ruby scripts/manage_characters.rb generate side     # Workplace NPC
ruby scripts/manage_characters.rb generate mentor   # Senior figure
```

### Generate Chapters

```bash
# Generate next chapter (interactive)
ruby scripts/generate_chapter.rb next

# Generate automatically without prompts
ruby scripts/generate_chapter.rb next --auto

# Regenerate an existing chapter
ruby scripts/generate_chapter.rb regenerate 1
```

### Improve Content

```bash
# Make a character funnier
ruby scripts/manage_characters.rb improve character_slug humor

# Improve chapter clarity
ruby scripts/generate_chapter.rb improve 1 clarity

# Ensure consistency
ruby scripts/generate_chapter.rb improve 1 consistency
```

### View Prompts

```bash
# See the prompt that would be used for a chapter
ruby scripts/generate_chapter.rb prompt 1
```

## üé≠ Character Types

### Hero Characters
Fellow programmers with impressive skills but not as perfect as One Review Man.
- Look up to or compete with One Review Man
- Have specialties that create comedy
- Represent positive programming practices

### Villain Characters  
Represent bad programming practices and create chaos.
- Challenge One Review Man's perfect code
- Embody everything wrong with software development
- Create obstacles through poor practices

### Side Characters
Workplace NPCs that provide comic relief.
- Fill specific roles in the tech company
- Have unique perspectives on One Review Man
- Represent common workplace archetypes

### Mentor Characters
Senior figures with deep programming wisdom.
- May have trained One Review Man or others
- Represent old-school vs new-school development
- Provide guidance during coding crises

## üé≠ Character Features

### Naming Conventions (NEW!)

**Mirrors One-Punch Man anime naming structure:**

#### Main Characters
- **One Review Man** (Professional Title) 
  - Real Name: **Satoru** („Éë„É≠„Éá„Ç£ of Saitama)
  - Most people call him "One Review Man" or "One Review Man-san"
  - Only his disciple calls him "Satoru" or "Satoru-sensei"

- **AI-Enhanced Disciple** (Professional Title)
  - Real Name: **Genki** („Éë„É≠„Éá„Ç£ of Genos)
  - Others call him "AI-Enhanced Disciple" or "Disciple-kun"
  - Satoru calls him "Genki" in private conversations

#### Dialogue Rules
- **Other characters ‚Üí Satoru**: "One Review Man", "One Review Man-san", "sir"
- **Genki ‚Üí Satoru**: "Satoru-sensei", "Satoru", "Master"
- **Satoru ‚Üí Genki**: "Genki", occasionally "Disciple"
- **Others ‚Üí Genki**: "AI-Enhanced Disciple", "Disciple-kun"
- **Internal monologue**: Can use real names

#### Other Characters
- May have both professional titles and real names
- Use workplace hierarchy when addressing the protagonist
- Follow formal/respectful address patterns typical in programming environments

#### Russian Transliteration (NEW!)
**Maintains consistency with original One-Punch Man Russian localization:**

- **"One Review Man" ‚Üí "–í–∞–Ω—Ä–µ–≤—å—é–º–µ–Ω"** (follows "One Punch Man" ‚Üí "–í–∞–Ω–ø–∞–Ω—á–º–µ–Ω" pattern)
- **"AI-Enhanced Disciple" ‚Üí "–ò–ò-–£—Å–∏–ª–µ–Ω–Ω—ã–π –£—á–µ–Ω–∏–∫"** (professional title translation)
- **Real names keep Japanese style:** "Satoru" ‚Üí "–°–∞—Ç–æ—Ä—É", "Genki" ‚Üí "–ì–µ–Ω–∫–∏"
- **Respectful address:** "–°–∞—Ç–æ—Ä—É-—Å–µ–Ω—Å–µ–π" for "Satoru-sensei"
- **Programming terms:** Natural mix of English and Russian ("–∫–æ–¥", "–ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç", but "pull request", "git")

### Automatic Content Generation
- Full chapter content with proper formatting
- Character interactions and dialogue
- Programming humor and parody elements
- Proper story progression
- **Consistent naming conventions** following One-Punch Man structure

### Character Integration
- Automatically includes relevant existing characters
- Creates new characters mentioned in the story
- Maintains character consistency across chapters
- Tracks character relationships and interactions
- **Uses proper naming conventions** (professional titles vs. real names)

### World Building
- Maintains consistency with established universe
- Tracks used plot devices to avoid repetition
- Builds on previous chapters and character development
- Integrates One-Punch Man parody elements

## üõ† Advanced Features

### Content Improvement Types

#### Humor Enhancement
- Adds more programming jokes and puns
- Enhances workplace comedy situations
- Improves timing and delivery of jokes
- Adds more absurdist elements

#### Clarity Improvement
- Improves readability and flow
- Clarifies confusing passages
- Enhances story structure
- Maintains humor while improving clarity

#### Consistency Check
- Ensures character behavior matches established traits
- Maintains world-building consistency
- Checks for continuity errors
- Aligns with established programming parody themes

### Mock Responses

If no OpenAI API key is configured, the system provides mock responses for development:
- Sample chapter content with programming humor
- Example characters with proper structure
- Allows testing without API costs
- Demonstrates expected output format

## üîß Configuration Options

### OpenAI Settings

The system uses the official [OpenAI Ruby SDK](https://github.com/openai/openai-ruby) for reliable, well-maintained API access.

```yaml
# Basic configuration
openai_api_key: your-api-key-here
model: gpt-4o-mini  # Default model for all tasks

# Task-specific models (NEW!)
models:
  generation: gpt-4o        # For chapters, characters, improvements
  translation: gpt-4o-mini  # For translation tasks
  chat: gpt-4o-mini        # For interactive chat

timeout: 240

# Task-specific options (NEW!)
task_options:
  generation:
    temperature: 0.8    # More creative for content
    max_tokens: 4000    # Longer responses for chapters
  translation:
    temperature: 0.3    # More consistent for translation
    max_tokens: 3000    # Adequate for translation
  chat:
    temperature: 0.7    # Balanced for conversations
    max_tokens: 2000    # Standard length
```

### Task-Specific Model Configuration

**NEW FEATURE**: You can now use different models for different types of tasks to optimize for quality and cost:

#### Content Generation Tasks
- **Chapters**: Higher quality model (gpt-4o) for creative writing
- **Characters**: Higher quality model (gpt-4o) for detailed character creation
- **Content Improvement**: Higher quality model (gpt-4o) for nuanced edits

#### Translation Tasks
- **Chapter Translation**: Cost-effective model (gpt-4o-mini) for consistent translation
- **Character Translation**: Cost-effective model (gpt-4o-mini) for efficient translation

#### Interactive Tasks
- **Chat/Demo**: Fast model (gpt-4o-mini) for quick responses

### Model Selection

Available OpenAI models:

| Model | Best For | Cost | Speed | Recommended Use |
|-------|----------|------|-------|-----------------|
| `gpt-4o-mini` | **Translation & Chat** - Great balance of quality and cost | Low | Fast | Translation, chat, testing |
| `gpt-4o` | **Content Generation** - Highest quality, complex tasks | High | Moderate | Chapters, characters, improvements |
| `gpt-4-turbo` | Good balance of capability and speed | Medium | Fast | Alternative for generation tasks |
| `gpt-3.5-turbo` | Simple tasks, fastest responses | Very Low | Very Fast | Development testing only |

### Advanced Configuration

```yaml
# Complete configuration example
openai_api_key: your-api-key-here
model: gpt-4o-mini  # Fallback model

# Task-specific models
models:
  generation: gpt-4o        # High quality for creative content
  translation: gpt-4o-mini  # Fast and cost-effective
  chat: gpt-4o-mini        # Quick responses

timeout: 240
max_retries: 2

# Global defaults
default_options:
  temperature: 0.7
  max_tokens: 2000

# Task-specific overrides
task_options:
  generation:
    temperature: 0.8    # More creative
    max_tokens: 4000    # Longer content
  translation:
    temperature: 0.3    # More consistent
    max_tokens: 3000    # Adequate length
  chat:
    temperature: 0.7    # Balanced
    max_tokens: 2000    # Standard length
```

## üéØ Best Practices

### API Usage
1. **Use task-specific models** for optimal cost and quality balance:
   - `gpt-4o` for content generation (chapters, characters)
   - `gpt-4o-mini` for translation and interactive chat
2. Start with the recommended configuration, then adjust based on your needs
3. Monitor your API usage and costs at https://platform.openai.com/usage
4. Set reasonable `max_tokens` limits to control costs

### Model Selection Strategy
1. **Content Generation**: Use `gpt-4o` for highest quality creative writing
2. **Translation**: Use `gpt-4o-mini` for cost-effective, consistent translation
3. **Development/Testing**: Use `gpt-4o-mini` or `gpt-3.5-turbo` to save costs
4. **Production**: Mix models based on task importance and budget

### Character Generation
1. Start with main characters (hero/mentor types)
2. Add supporting characters gradually
3. Create villains to provide conflict
4. Use side characters for comic relief

### Chapter Generation
1. Generate chapters in order for better continuity
2. Review and edit generated content before finalizing
3. Use improvement commands to enhance specific aspects
4. Translate chapters after English version is complete

### Content Quality
1. Always review AI-generated content before publishing
2. Use improvement commands to refine humor and clarity
3. Maintain consistency with established characters
4. Keep the programming parody theme consistent

### Cost Optimization
1. Use `gpt-4o` only for final content generation
2. Use `gpt-4o-mini` for drafts, translation, and testing
3. Set appropriate `max_tokens` limits for each task type
4. Consider using `gpt-3.5-turbo` for development and experimentation

## üêõ Troubleshooting

### Common Issues

#### "No OpenAI client configured"
- Run `ruby scripts/demo_llm.rb setup` to create config
- Edit `scripts/llm_config.yml` with your API key
- Get API key from https://platform.openai.com/api-keys

#### "OpenAI API Error" messages
- Verify API key is correct and active
- Check you have API credits/quota available
- Ensure internet connection is working
- Try a different model (e.g., gpt-3.5-turbo for testing)

#### Generation quality issues
- Try different temperature settings (0.6-0.8)
- Use more specific prompts or character types
- Run improvement commands on generated content
- Consider switching to gpt-4o for higher quality

#### Rate limiting errors
- The official SDK handles retries automatically
- Consider adding delays between requests for bulk operations
- Check your rate limits at https://platform.openai.com/account/limits

### Getting Help

1. Run the demo for interactive guidance: `ruby scripts/demo_llm.rb`
2. Check script help: `ruby scripts/generate_chapter.rb` (no arguments)
3. View configuration: Option 5 in the demo menu
4. Check the existing prompts in `scripts/prompts/` for examples

## üìÅ File Structure

```
scripts/
‚îú‚îÄ‚îÄ llm_service.rb           # Core OpenAI integration
‚îú‚îÄ‚îÄ generate_chapter.rb      # Chapter generation with AI
‚îú‚îÄ‚îÄ manage_characters.rb     # Character management with AI
‚îú‚îÄ‚îÄ demo_llm.rb             # Interactive demo
‚îú‚îÄ‚îÄ llm_config.yml          # OpenAI configuration (created)
‚îî‚îÄ‚îÄ prompts/
    ‚îú‚îÄ‚îÄ chapter_prompts.txt  # Chapter generation prompts
    ‚îî‚îÄ‚îÄ character_prompts.txt # Character generation prompts
```

## üé¨ Example Workflow

1. **Set up OpenAI configuration**
   ```bash
   # Recommended: Set environment variable (secure)
   export OPENAI_API_KEY="your-api-key-here"
   
   # Create config file for non-sensitive settings
   ruby scripts/demo_llm.rb setup
   ```

2. **Generate initial characters**
   ```bash
   ruby scripts/manage_characters.rb generate hero
   ruby scripts/manage_characters.rb generate side
   ```

3. **Generate first chapter**
   ```bash
   ruby scripts/generate_chapter.rb next
   ```

4. **Improve the chapter**
   ```bash
   ruby scripts/generate_chapter.rb improve 1 humor
   ```

5. **Translate to other languages**
   ```bash
   ruby scripts/translate_content.rb chapter 1 ru
   ```

## üîÆ Future Extensibility

The `LLMService` class is designed as an abstraction layer. While currently OpenAI-only, it can be extended to support additional providers in the future:

- Other API providers (Claude, Cohere, etc.)
- Local models (Ollama, LM Studio)
- Custom fine-tuned models
- Multi-provider fallbacks

The interface remains consistent, making it easy to add new providers without changing the higher-level generation scripts.

Enjoy creating hilarious programming comedy with AI assistance! üöÄ
</file>

<file path=".gitignore">
_site
.sass-cache
.jekyll-cache
.jekyll-metadata
vendor
</file>

<file path=".rubocop_todo.yml">
# This configuration was generated by
# `rubocop --auto-gen-config`
# on 2025-06-01 20:24:15 UTC using RuboCop version 1.75.8.
# The point is for the user to remove these configuration records
# one by one as the offenses are removed from the code base.
# Note that changes in the inspected code, or installation of new
# versions of RuboCop, may require this file to be generated again.

# Offense count: 57
# Configuration parameters: AllowedMethods, AllowedPatterns, CountRepeatedAttributes.
Metrics/AbcSize:
  Max: 71

# Offense count: 6
# Configuration parameters: CountComments, CountAsOne, AllowedMethods, AllowedPatterns.
# AllowedMethods: refine
Metrics/BlockLength:
  Max: 40

# Offense count: 6
# Configuration parameters: CountComments, CountAsOne.
Metrics/ClassLength:
  Max: 689

# Offense count: 26
# Configuration parameters: AllowedMethods, AllowedPatterns.
Metrics/CyclomaticComplexity:
  Max: 20

# Offense count: 74
# Configuration parameters: CountComments, CountAsOne, AllowedMethods, AllowedPatterns.
Metrics/MethodLength:
  Max: 75

# Offense count: 1
# Configuration parameters: CountComments, CountAsOne.
Metrics/ModuleLength:
  Max: 294

# Offense count: 3
# Configuration parameters: CountKeywordArgs, MaxOptionalParameters.
Metrics/ParameterLists:
  Max: 8

# Offense count: 22
# Configuration parameters: AllowedMethods, AllowedPatterns.
Metrics/PerceivedComplexity:
  Max: 22

# Offense count: 2
Naming/AccessorMethodName:
  Exclude:
    - 'scripts/book_utils.rb'
    - 'scripts/manage_characters.rb'

# Offense count: 5
# Configuration parameters: AllowedConstants.
Style/Documentation:
  Exclude:
    - 'spec/**/*'
    - 'test/**/*'
    - 'scripts/book_utils.rb'
    - 'scripts/generate_chapter.rb'
    - 'scripts/manage_characters.rb'
    - 'scripts/reset_book.rb'
    - 'scripts/translate_content.rb'

# Offense count: 10
# This cop supports safe autocorrection (--autocorrect).
Style/IfUnlessModifier:
  Exclude:
    - 'scripts/generate_chapter.rb'
    - 'scripts/llm_service.rb'
    - 'scripts/manage_characters.rb'
    - 'scripts/translate_content.rb'

# Offense count: 1
Style/MultilineBlockChain:
  Exclude:
    - 'scripts/book_utils.rb'

# Offense count: 12
# This cop supports safe autocorrection (--autocorrect).
# Configuration parameters: AllowHeredoc, AllowURI, URISchemes, IgnoreCopDirectives, AllowedPatterns, SplitStrings.
# URISchemes: http, https
Layout/LineLength:
  Max: 692
</file>

<file path="404.html">
---
permalink: /404.html
layout: page
---

<style type="text/css" media="screen">
  .container {
    margin: 10px auto;
    max-width: 600px;
    text-align: center;
  }
  h1 {
    margin: 30px 0;
    font-size: 4em;
    line-height: 1;
    letter-spacing: -1px;
  }
</style>

<div class="container">
  <h1>404</h1>

  <p><strong>Page not found :(</strong></p>
  <p>The requested page could not be found.</p>
</div>
</file>

<file path="CNAME">
one-review-man.ctln.pw
</file>

<file path="README.md">
# One Review Man - AI Generated Programming Comedy

A programming parody of "One-Punch Man" generated chapter by chapter using AI. Built with Jekyll and designed for GitHub Pages with multilingual support (English and Russian).

## Project Overview

This is a humorous programming book that parodies the popular manga/anime "[One-Punch Man](https://en.wikipedia.org/wiki/One-Punch_Man)" in a tech workplace setting. Just as [Saitama](https://en.wikipedia.org/wiki/Saitama_(One-Punch_Man)) can defeat any enemy with one punch, **One Review Man** is a super-programmer who writes perfect code that passes every code review on the first try.

### The Parody Concept

- **One Review Man**: The protagonist, master programmer (parody of Saitama)
  - Writes flawless code that never needs revisions
  - All pull requests are instantly approved and merged
  - Has become bored with his overwhelming programming abilities
  
- **The AI-Enhanced Disciple**: A cyborg-like character with neurointerface (parody of Genos)
  - Connected to AI systems to enhance coding abilities
  - Desperately seeks to learn One Review Man's secrets
  - Still cannot achieve the master's level despite technological augmentation

**All content is created in English first**, then translated to other languages to ensure story consistency and character coherence across all language versions.

## Multilingual Approach

- **Primary Language**: English (where all content is generated)
- **Translations**: Russian (and potentially others)
- **Story Consistency**: Same plot, characters, and relationships across all languages
- **Workflow**: Generate ‚Üí Translate ‚Üí Sync

## Project Structure

```
one-review-man/
‚îú‚îÄ‚îÄ _config.yml              # Jekyll configuration with multilingual support
‚îú‚îÄ‚îÄ _data/                   # Data files
‚îÇ   ‚îú‚îÄ‚îÄ characters.en.yml    # English character database
‚îÇ   ‚îú‚îÄ‚îÄ characters.ru.yml    # Russian character translations
‚îÇ   ‚îú‚îÄ‚îÄ book_metadata.en.yml # English book settings
‚îÇ   ‚îú‚îÄ‚îÄ book_metadata.ru.yml # Russian book settings
‚îÇ   ‚îú‚îÄ‚îÄ strings.yml          # UI translations
‚îÇ   ‚îî‚îÄ‚îÄ generation_log.yml   # Generation tracking
‚îú‚îÄ‚îÄ _layouts/                # Jekyll layouts
‚îÇ   ‚îú‚îÄ‚îÄ chapter.html         # Chapter page layout
‚îÇ   ‚îî‚îÄ‚îÄ character.html       # Character profile layout
‚îú‚îÄ‚îÄ _includes/               # Reusable components
‚îÇ   ‚îú‚îÄ‚îÄ character_card.html  # Character display card
‚îÇ   ‚îú‚îÄ‚îÄ character_mention.html # Inline character links
‚îÇ   ‚îî‚îÄ‚îÄ chapter_nav.html     # Chapter navigation
‚îú‚îÄ‚îÄ _chapters/               # Generated chapters
‚îÇ   ‚îú‚îÄ‚îÄ 001-chapter-1.md     # English chapters
‚îÇ   ‚îî‚îÄ‚îÄ 001-chapter-1.ru.md  # Russian translations
‚îú‚îÄ‚îÄ _characters/             # Character profile pages
‚îÇ   ‚îú‚îÄ‚îÄ protagonist.md       # English character pages
‚îÇ   ‚îî‚îÄ‚îÄ protagonist.ru.md    # Russian character pages
‚îú‚îÄ‚îÄ scripts/                 # Ruby generation and management scripts
‚îÇ   ‚îú‚îÄ‚îÄ generate_chapter.rb  # Chapter generation (English only)
‚îÇ   ‚îú‚îÄ‚îÄ manage_characters.rb # Character management (English primary)
‚îÇ   ‚îú‚îÄ‚îÄ translate_content.rb # Translation tool
‚îÇ   ‚îú‚îÄ‚îÄ book_utils.rb        # Shared utilities
‚îÇ   ‚îî‚îÄ‚îÄ prompts/             # AI prompt templates
‚îú‚îÄ‚îÄ index.md                 # English landing page
‚îú‚îÄ‚îÄ index.ru.md              # Russian landing page
‚îú‚îÄ‚îÄ chapters.md              # English chapter index
‚îî‚îÄ‚îÄ characters.md            # English character index
```

## Getting Started

### Prerequisites

- Ruby (for Jekyll and scripts)
- Jekyll (`gem install jekyll bundler`)

### Setup

1. Clone this repository
2. Install dependencies:
   ```bash
   bundle install
   ```

3. Start Jekyll development server:
   ```bash
   bundle exec jekyll serve
   ```

4. Open http://localhost:4000 for English or http://localhost:4000/ru for Russian

## Content Creation Workflow

### 1. Create Content in English

#### Generate a New Chapter
```bash
# Generate next chapter structure and prompt
ruby scripts/generate_chapter.rb next

# Regenerate prompt for existing chapter
ruby scripts/generate_chapter.rb prompt 1
```

#### Create Characters
```bash
# Add new character interactively (English only)
ruby scripts/manage_characters.rb add

# List all characters with translation status
ruby scripts/manage_characters.rb list

# Show character details
ruby scripts/manage_characters.rb show character_slug
```

### 2. Translate to Other Languages

#### Translate Characters
```bash
# Translate specific character
ruby scripts/translate_content.rb character protagonist ru

# Translate all characters at once
ruby scripts/translate_content.rb all-characters ru
```

#### Translate Chapters
```bash
# Translate specific chapter
ruby scripts/translate_content.rb chapter 1 ru
```

#### Check Translation Status
```bash
# See what's translated and what's missing
ruby scripts/translate_content.rb status ru
```

### 3. Sync Metadata Across Languages
```bash
# Sync chapter metadata (character appearances, etc.)
ruby scripts/translate_content.rb sync 1 ru

# Sync character metadata across languages
ruby scripts/manage_characters.rb sync protagonist
```

## Content Guidelines

### Chapter Creation
1. **Generate structure**: `ruby scripts/generate_chapter.rb next`
2. **Get AI prompt**: Copy the generated prompt to your AI (includes One-Punch Man parody context)
3. **Add content**: Edit the chapter file with AI-generated programming comedy content
4. **Update metadata**: Fill in title, summary, new characters
5. **Translate**: Use translation script for other languages

### Character Development
- Create programmer archetypes with distinct coding styles and personalities
- Reference One-Punch Man character dynamics adapted to programming context
- Include consistent programming abilities and quirks across all appearances
- Translate personality while maintaining programming expertise and relationships
- Sync coding skill levels and character relationships across all languages

### Programming Comedy Themes
- Code review scenarios (One Review Man's code is always perfect)
- Debugging disasters and production emergencies
- Framework wars and technology adoption
- Pair programming dynamics and mentorship
- Tech company culture absurdities
- Open source contribution drama
- Legacy code archaeology and technical debt
- Conference presentations and tech talks

## Multilingual Features

### Automatic Language Detection
- URLs: `/` (English) vs `/ru/` (Russian)
- Content filtering by language
- Language switcher on all pages

### Translation Management
- Preserves story structure and relationships
- Maintains character consistency
- Syncs metadata automatically
- Tracks translation status

### Supported Languages
- **English** (en) - Primary
- **Russian** (ru) - Translation
- Easily extensible to other languages

## AI Integration

The project is designed to work with AI generation:

1. **Structured Prompts**: Templates with context about previous chapters and characters
2. **Context Management**: Scripts provide relevant story context
3. **Consistency Tracking**: Generation log prevents repetitive plots
4. **Character Relationships**: Automatically maintained across languages

## Deployment

This project works with GitHub Pages:

1. Push to a GitHub repository
2. Enable GitHub Pages in repository settings
3. Site available at `https://username.github.io/repository-name`
4. Language versions: `https://username.github.io/repository-name/ru/`

## Example Workflow

```bash
# 1. Create your first character (the AI-Enhanced Disciple)
ruby scripts/manage_characters.rb add
# Enter: "Genos-9000", "Cyborg programmer with neurointerface seeking to learn from One Review Man", "persistent, analytical, technology-obsessed"

# 2. Generate first chapter
ruby scripts/generate_chapter.rb next
# Copy prompt (includes One-Punch Man parody context), generate with AI, paste content into chapter file

# 3. Translate character to Russian
ruby scripts/translate_content.rb character genos_9000 ru
# Enter: "–ì–µ–Ω–æ—Å-9000", "–ü—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç-–∫–∏–±–æ—Ä–≥ —Å –Ω–µ–π—Ä–æ–∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–æ–º, —Å—Ç—Ä–µ–º—è—â–∏–π—Å—è —É—á–∏—Ç—å—Å—è —É One Review Man", etc.

# 4. Translate chapter to Russian
ruby scripts/translate_content.rb chapter 1 ru
# Enter translated title, summary, and content

# 5. Check status
ruby scripts/translate_content.rb status ru
```

## Key Benefits

### ‚úÖ Story Consistency
- Same plot and character development across all languages
- Relationships and timeline remain identical
- No divergent storylines

### ‚úÖ Translation Efficiency
- Translate once, maintain everywhere
- Metadata syncing across languages
- Clear tracking of what needs translation

### ‚úÖ Scalable
- Easy to add new languages
- Automated cross-language linking
- Consistent file naming and structure

### ‚úÖ SEO Friendly
- Clean URLs for each language
- Proper language tags
- Search engine friendly structure

## Contributing

This is a personal humor book project, but suggestions for improvements to the multilingual system are welcome!

## License

This project is available under MIT license.

---

*"One Review Man" - Where AI meets programming parody, one perfect pull request at a time. Now in multiple languages with perfect consistency!* ü§ñüìöüíª‚ö°
</file>

<file path="_includes/character_card.html">
<div class="character-card">
  <div class="character-card-header">
    <h4 class="character-card-name">
      {% assign character_page = site.characters | where: "slug", include.character.slug | first %}
      {% if character_page %}
        <a href="{{ character_page.url }}">{{ include.character.name }}</a>
      {% else %}
        <a href="/characters/{{ include.character.slug | slugify }}">{{ include.character.name }}</a>
      {% endif %}
    </h4>
  </div>
  
  <div class="character-card-body">
    <p class="character-card-description">{{ include.character.description }}</p>
    
    {% if include.character.personality_traits and include.character.personality_traits.size > 0 %}
      <div class="character-card-traits">
        {% for trait in include.character.personality_traits %}
          <span class="trait-tag">{{ trait }}</span>
        {% endfor %}
      </div>
    {% endif %}
    
    {% if include.character.catchphrase %}
      <div class="character-catchphrase">
        <em>"{{ include.character.catchphrase }}"</em>
      </div>
    {% endif %}
  </div>
</div>

<style>
.character-card {
  border: 1px solid #e1e5e9;
  border-radius: 8px;
  padding: 1rem;
  margin: 0.5rem 0;
  background-color: white;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.character-card:hover {
  transform: translateY(-2px);
  box-shadow: 0 4px 8px rgba(0,0,0,0.15);
}

.character-card-header {
  margin-bottom: 0.5rem;
}

.character-card-name {
  margin: 0;
  color: #2c3e50;
}

.character-card-name a {
  color: inherit;
  text-decoration: none;
}

.character-card-name a:hover {
  color: #3498db;
}

.character-card-description {
  color: #7f8c8d;
  margin: 0.5rem 0;
  line-height: 1.4;
}

.character-card-traits {
  display: flex;
  flex-wrap: wrap;
  gap: 0.3rem;
  margin: 0.5rem 0;
}

.trait-tag {
  background-color: #3498db;
  color: white;
  padding: 0.2rem 0.5rem;
  border-radius: 10px;
  font-size: 0.8rem;
}

.character-catchphrase {
  margin-top: 0.5rem;
  padding: 0.5rem;
  background-color: #f8f9fa;
  border-left: 3px solid #3498db;
  font-style: italic;
  color: #5a6c7d;
}
</style>
</file>

<file path="_includes/character_mention.html">
<span class="character-mention">
  {% assign character_page = site.characters | where: "slug", include.character.slug | first %}
  {% if character_page %}
    <a href="{{ character_page.url }}" 
       class="character-link" 
       title="{{ include.character.description }}">
      {{ include.character.name }}
    </a>
  {% else %}
    <a href="/characters/{{ include.character.slug | slugify }}" 
       class="character-link" 
       title="{{ include.character.description }}">
      {{ include.character.name }}
    </a>
  {% endif %}
</span>

<style>
.character-mention {
  display: inline-block;
}

.character-link {
  color: #3498db;
  text-decoration: none;
  padding: 0.2rem 0.5rem;
  background-color: #ecf0f1;
  border-radius: 12px;
  font-size: 0.9rem;
  font-weight: 500;
  transition: all 0.2s ease;
}

.character-link:hover {
  background-color: #3498db;
  color: white;
  text-decoration: none;
}
</style>
</file>

<file path="_includes/header.html">
<header class="site-header" role="banner">
  <div class="wrapper">
    <a class="site-title" rel="author" href="{{ "/" | relative_url }}">{{ site.title | escape }}</a>

    <!-- jekyll-polyglot will process ferh= into href= through the static_href liquid block tag without relativizing the url; useful for making language navigation switchers  -->
    {% for tongue in site.languages %}
      {% if tongue != site.active_lang %}
        <a  {% static_href %}href="{% if tongue == site.default_lang %}{{site.baseurl}}{{page.url}}{% else %}{{site.baseurl}}/{{ tongue }}{{page.url}}{% endif %}"{% endstatic_href %} >{{ tongue }}</a>{%- if forloop.last == false -%}{{" "}}{{ site.langsep }}{%- endif -%}
      {% endif %}
    {% endfor %}
  </div>
</header>
</file>

<file path="_layouts/chapter.html">
---
layout: default
---

<article class="chapter">
  <div class="chapter-content">
    {{ content }}
  </div>

  <!-- <nav class="chapter-navigation">
    {% include chapter_nav.html %}
  </nav> -->
</article>

<style>
.chapter-header {
  border-bottom: 2px solid #e1e5e9;
  padding-bottom: 1rem;
  margin-bottom: 2rem;
}

.chapter-title {
  color: #2c3e50;
  margin-bottom: 0.5rem;
}

.chapter-meta {
  display: flex;
  gap: 1rem;
  color: #7f8c8d;
  font-size: 0.9rem;
}

.chapter-summary {
  margin-top: 1rem;
  padding: 1rem;
  background-color: #f8f9fa;
  border-left: 4px solid #3498db;
}

.chapter-characters {
  margin-bottom: 2rem;
  padding: 1rem;
  background-color: #f1f2f6;
  border-radius: 8px;
}

.character-list {
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
  margin-top: 0.5rem;
}

.chapter-content {
  line-height: 1.6;
  font-size: 1.1rem;
}

.new-characters {
  margin-top: 2rem;
  padding: 1rem;
  background-color: #e8f5e8;
  border-radius: 8px;
}

.chapter-navigation {
  margin-top: 3rem;
  padding-top: 2rem;
  border-top: 1px solid #e1e5e9;
}
</style>
</file>

<file path="_layouts/character.html">
---
layout: default
---

<article class="character-profile">
  <header class="character-header">
    <h1 class="character-name">{{ page.name }}</h1>
    {% if page.description %}
      <p class="character-description">{{ page.description }}</p>
    {% endif %}
  </header>

  <div class="character-details">
    {% if page.personality_traits and page.personality_traits.size > 0 %}
      <div class="personality-traits">
        <h3>Personality Traits</h3>
        <ul class="trait-list">
          {% for trait in page.personality_traits %}
            <li class="trait">{{ trait }}</li>
          {% endfor %}
        </ul>
      </div>
    {% endif %}

    {% if page.first_appearance %}
      <div class="first-appearance">
        <h3>First Appearance</h3>
        {% assign chapter_file = page.first_appearance | append: ".md" %}
        {% assign chapter = site.chapters | where: "slug", page.first_appearance | first %}
        {% if chapter %}
          <p><a href="{{ chapter.url }}">{{ chapter.title }}</a></p>
        {% else %}
          <p>{{ page.first_appearance }}</p>
        {% endif %}
      </div>
    {% endif %}

    {% if page.relationships and page.relationships.size > 0 %}
      <div class="relationships">
        <h3>Relationships</h3>
        <ul class="relationship-list">
          {% for relationship in page.relationships %}
            <li class="relationship">
              {% assign other_character = site.data.characters.characters[relationship.character] %}
              {% assign other_character_page = site.characters | where: "slug", relationship.character | first %}
              {% if other_character %}
                {% if other_character_page %}
                  <strong><a href="{{ other_character_page.url }}">{{ other_character.name }}</a></strong> - {{ relationship.type }}
                {% else %}
                  <strong><a href="/characters/{{ relationship.character | slugify }}">{{ other_character.name }}</a></strong> - {{ relationship.type }}
                {% endif %}
              {% else %}
                <strong>{{ relationship.character }}</strong> - {{ relationship.type }}
              {% endif %}
            </li>
          {% endfor %}
        </ul>
      </div>
    {% endif %}
  </div>

  <div class="character-content">
    {{ content }}
  </div>

  {% comment %} Find all chapters this character appears in {% endcomment %}
  {% assign character_chapters = site.chapters | where_exp: "chapter", "chapter.characters contains page.slug" %}
  {% if character_chapters.size > 0 %}
    <div class="character-appearances">
      <h3>Chapter Appearances</h3>
      <ul class="appearance-list">
        {% assign sorted_chapters = character_chapters | sort: "chapter_number" %}
        {% for chapter in sorted_chapters %}
          <li class="appearance">
            <a href="{{ chapter.url }}">{{ chapter.title }}</a>
            {% if chapter.new_characters contains page.slug %}
              <span class="debut-badge">Debut</span>
            {% endif %}
          </li>
        {% endfor %}
      </ul>
    </div>
  {% endif %}

  <nav class="character-navigation">
    <a href="/characters" class="back-link">‚Üê All Characters</a>
  </nav>
</article>

<style>
.character-profile {
  max-width: 800px;
  margin: 0 auto;
}

.character-header {
  text-align: center;
  padding: 2rem 0;
  border-bottom: 2px solid #30363d;
  margin-bottom: 2rem;
}

.character-name {
  color: #f0f6fc;
  margin-bottom: 1rem;
  font-size: 2.5rem;
}

.character-description {
  font-size: 1.2rem;
  color: #8b949e;
  font-style: italic;
  max-width: 600px;
  margin: 0 auto;
}

.character-details {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
  gap: 2rem;
  margin-bottom: 2rem;
}

.personality-traits, .first-appearance, .relationships {
  padding: 1.5rem;
  background-color: #21262d;
  border-radius: 8px;
  border-left: 4px solid #58a6ff;
}

.trait-list {
  list-style: none;
  padding: 0;
  display: flex;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.trait {
  background-color: #58a6ff;
  color: #f0f6fc;
  padding: 0.3rem 0.8rem;
  border-radius: 15px;
  font-size: 0.9rem;
}

.relationship-list, .appearance-list {
  list-style: none;
  padding: 0;
}

.relationship, .appearance {
  padding: 0.5rem 0;
  border-bottom: 1px solid #30363d;
}

.relationship:last-child, .appearance:last-child {
  border-bottom: none;
}

.debut-badge {
  background-color: #f85149;
  color: #f0f6fc;
  padding: 0.2rem 0.5rem;
  border-radius: 10px;
  font-size: 0.8rem;
  margin-left: 0.5rem;
}

.character-content {
  line-height: 1.6;
  margin-bottom: 2rem;
}

.character-appearances {
  margin-top: 2rem;
  padding: 1.5rem;
  background-color: #21262d;
  border-radius: 8px;
}

.character-navigation {
  margin-top: 3rem;
  padding-top: 2rem;
  border-top: 1px solid #30363d;
  text-align: center;
}

.back-link {
  color: #58a6ff;
  text-decoration: none;
  font-weight: bold;
}

.back-link:hover {
  text-decoration: underline;
}
</style>
</file>

<file path=".github/workflows/jekyll.yml">
# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

# Sample workflow for building and deploying a Jekyll site to GitHub Pages
name: Deploy Jekyll site to Pages

on:
  # Runs on pushes targeting the default branch
  push:
    branches: ["main"]

  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:

# Sets permissions of the GITHUB_TOKEN to allow deployment to GitHub Pages
permissions:
  contents: read
  pages: write
  id-token: write

# Allow only one concurrent deployment, skipping runs queued between the run in-progress and latest queued.
# However, do NOT cancel in-progress runs as we want to allow these production deployments to complete.
concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  # Build job
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      - name: Setup Ruby
        # https://github.com/ruby/setup-ruby/releases/tag/v1.207.0
        uses: ruby/setup-ruby@4a9ddd6f338a97768b8006bf671dfbad383215f4
        with:
          # ruby-version: '3.1' # Not needed with a .ruby-version file
          bundler-cache: true # runs 'bundle install' and caches installed gems automatically
          cache-version: 0 # Increment this number if you need to re-download cached gems
      - name: Setup Pages
        id: pages
        uses: actions/configure-pages@v5
      - name: Build with Jekyll
        # Outputs to the './_site' directory by default
        run: bundle exec jekyll build --baseurl "${{ steps.pages.outputs.base_path }}"
        env:
          JEKYLL_ENV: production
      - name: Upload artifact
        # Automatically uploads an artifact from the './_site' directory by default
        uses: actions/upload-pages-artifact@v3

  # Deployment job
  deploy:
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
</file>

<file path="scripts/book_utils.rb">
# frozen_string_literal: true

require 'yaml'
require 'fileutils'

module BookUtils
  DATA_DIR = '_data'
  CHAPTERS_DIR = '_chapters'
  CHARACTERS_DIR = '_characters'

  # Data file loading methods - support both simple and language-specific patterns
  def load_book_data(lang = nil)
    file_path = File.join(DATA_DIR, 'book_metadata.yml')
    data = load_yaml_file(file_path)

    if lang && data[lang]
      # Language-specific data
      data[lang]
    elsif lang.nil? && data['en']
      # Default to English for generation scripts
      data['en']
    elsif lang.nil?
      # Legacy single-language format
      data
    else
      # Language not found, return empty structure
      {
        'book' => {},
        'generation' => {},
        'themes' => {},
        'status' => {}
      }
    end
  end

  def load_characters(lang = nil)
    file_path = File.join(DATA_DIR, 'characters.yml')
    data = load_yaml_file(file_path) || { 'characters' => {} }

    if lang && data[lang]
      # Language-specific data
      data[lang]
    elsif lang.nil? && data['en']
      # Default to English for generation scripts
      data['en']
    elsif lang.nil?
      # Legacy single-language format or simple case
      data['characters'] ? data : { 'characters' => data }
    else
      # Language not found, return empty structure
      { 'characters' => {} }
    end
  end

  def load_generation_log
    file_path = File.join(DATA_DIR, 'generation_log.yml')
    load_yaml_file(file_path)
  end

  def load_strings(lang = 'en')
    file_path = File.join(DATA_DIR, 'strings.yml')
    data = load_yaml_file(file_path) || {}
    data[lang] || data['en'] || {}
  end

  # Data file saving methods - support both simple and language-specific patterns
  def save_book_data(data, lang = nil)
    file_path = File.join(DATA_DIR, 'book_metadata.yml')

    existing_data = load_yaml_file(file_path) || {}
    if lang
      # Save to language-specific section
      existing_data[lang] = data
    else
      # For generation scripts, assume English and maintain language structure
      existing_data['en'] = data
    end
    save_yaml_file(file_path, existing_data)
  end

  def save_characters(data, lang = nil)
    file_path = File.join(DATA_DIR, 'characters.yml')

    existing_data = load_yaml_file(file_path) || {}
    if lang
      # Save to language-specific section
      existing_data[lang] = data
    else
      # For generation scripts, assume English and maintain language structure
      existing_data['en'] = data
    end
    save_yaml_file(file_path, existing_data)
  end

  def save_generation_log(data)
    file_path = File.join(DATA_DIR, 'generation_log.yml')
    save_yaml_file(file_path, data)
  end

  # File operation helpers
  def load_yaml_file(file_path)
    if File.exist?(file_path)
      YAML.load_file(file_path) || {}
    else
      puts "Warning: #{file_path} not found, returning empty hash"
      {}
    end
  end

  def save_yaml_file(file_path, data)
    FileUtils.mkdir_p(File.dirname(file_path))
    File.write(file_path, data.to_yaml)
  end

  # Content helpers
  def get_all_chapters(lang = nil)
    return [] unless Dir.exist?(CHAPTERS_DIR)

    # Filter chapters based on language
    pattern = if lang && lang != 'en'
                "#{CHAPTERS_DIR}/*.#{lang}.md"
              else
                # For English or no language specified, get base chapters (no language suffix)
                "#{CHAPTERS_DIR}/*.md"
              end

    chapters = Dir.glob(pattern).reject do |file|
      # Skip files with language suffixes when looking for English/base chapters
      lang.nil? && File.basename(file, '.md').include?('.')
    end.map do |file|
      parse_chapter_file(file)
    end

    chapters.sort_by { |chapter| chapter['chapter_number'] || 0 }
  end

  def get_all_character_slugs(lang = nil)
    characters = load_characters(lang)
    characters['characters']&.keys || []
  end

  def get_characters_by_slugs(slugs, lang = nil)
    characters = load_characters(lang)
    return [] if characters.empty? || !characters['characters']

    slugs.filter_map { |slug| characters['characters'][slug] }
  end

  # Generation helpers
  def log_generation(type, content_id, details = {})
    log = load_generation_log
    log['generations'] ||= []

    generation_entry = {
      'date' => Date.today.to_s,
      'type' => type,
      'content_id' => content_id
    }.merge(details)

    log['generations'] << generation_entry
    save_generation_log(log)
  end

  def get_used_plot_devices
    log = load_generation_log
    log['used_plot_devices'] || []
  end

  def add_used_plot_device(device)
    log = load_generation_log
    log['used_plot_devices'] ||= []

    return if log['used_plot_devices'].include?(device)

    log['used_plot_devices'] << device
    save_generation_log(log)
  end

  # Character relationship helpers
  def update_character_interaction(char1_slug, char2_slug, interaction_type)
    log = load_generation_log
    log['character_interactions'] ||= {}

    key = [char1_slug, char2_slug].sort.join('_')
    log['character_interactions'][key] ||= []
    log['character_interactions'][key] << {
      'type' => interaction_type,
      'date' => Date.today.to_s
    }

    save_generation_log(log)
  end

  def get_character_interactions(char_slug)
    log = load_generation_log
    interactions = log['character_interactions'] || {}

    interactions.select do |key, _|
      key.split('_').include?(char_slug)
    end
  end

  # Validation helpers
  def validate_chapter_structure(chapter_data)
    required_fields = %w[title chapter_number]
    missing_fields = required_fields.select { |field| chapter_data[field].nil? }

    if missing_fields.any?
      puts "Warning: Chapter missing required fields: #{missing_fields.join(', ')}"
      return false
    end

    true
  end

  def validate_character_structure(character_data)
    required_fields = %w[name description]
    missing_fields = required_fields.select { |field| character_data[field].nil? || character_data[field].empty? }

    if missing_fields.any?
      puts "Warning: Character missing required fields: #{missing_fields.join(', ')}"
      return false
    end

    true
  end

  private

  def parse_chapter_file(file_path)
    content = File.read(file_path)
    match = content.match(/\A---\s*\n(.*?)\n---\s*\n(.*)/m)

    if match
      front_matter = YAML.safe_load(match[1]) || {}
      content_text = match[2]

      front_matter.merge({
                           'content' => content_text,
                           'file_path' => file_path
                         })
    else
      {
        'title' => File.basename(file_path, '.md'),
        'content' => content,
        'file_path' => file_path
      }
    end
  rescue StandardError => e
    puts "Error parsing #{file_path}: #{e.message}"
    { 'file_path' => file_path, 'title' => File.basename(file_path, '.md') }
  end

  def slugify(text)
    text.downcase.gsub(/[^a-z0-9]+/, '_').gsub(/^_|_$/, '')
  end

  def format_chapter_filename(chapter_number)
    "#{chapter_number.to_s.rjust(3, '0')}-chapter.md"
  end

  def extract_chapter_content(file_path)
    return '' unless File.exist?(file_path)

    content = File.read(file_path)
    match = content.match(/\A---\s*\n.*?\n---\s*\n(.*)/m)

    match ? match[1].strip : content.strip
  end

  def update_chapter_content(file_path, new_content)
    return false unless File.exist?(file_path)

    content = File.read(file_path)
    match = content.match(/(\A---\s*\n.*?\n---\s*\n)(.*)/m)

    if match
      updated_content = match[1] + new_content
      File.write(file_path, updated_content)
    else
      File.write(file_path, new_content)
    end
    true
  end

  def update_chapter_front_matter(file_path, updates)
    return false unless File.exist?(file_path)

    content = File.read(file_path)
    match = content.match(/\A(---\s*\n)(.*?)(\n---\s*\n)(.*)/m)

    if match
      front_matter = YAML.safe_load(match[2]) || {}
      front_matter.merge!(updates)

      updated_content = match[1] + front_matter.to_yaml + match[3] + match[4]
      File.write(file_path, updated_content)
      true
    else
      false
    end
  end

  def create_character_page(slug, character_data)
    filename = "_characters/#{slug}.md"

    front_matter = {
      'layout' => 'character',
      'name' => character_data['name'],
      'slug' => slug,
      'description' => character_data['description'],
      'personality_traits' => character_data['personality_traits'] || [],
      'first_appearance' => character_data['first_appearance'],
      'relationships' => character_data['relationships'] || []
    }

    File.open(filename, 'w') do |file|
      file.puts '---'
      file.puts front_matter.to_yaml.lines[1..]
      file.puts '---'
      file.puts ''
      file.puts "## About #{character_data['name']}"
      file.puts ''
      file.puts character_data['description']
      file.puts ''

      if character_data['backstory']
        file.puts '## Backstory'
        file.puts ''
        file.puts character_data['backstory']
        file.puts ''
      end

      if character_data['quirks']
        file.puts '## Notable Quirks'
        file.puts ''
        file.puts character_data['quirks']
        file.puts ''
      end

      if character_data['catchphrase']
        file.puts '## Catchphrase'
        file.puts ''
        file.puts "> \"#{character_data['catchphrase']}\""
        file.puts ''
      end

      file.puts '## Appearances'
      file.puts ''
      file.puts "First appeared in: #{character_data['first_appearance'] || 'To be determined'}"
      file.puts ''
    end
  end

  def update_character_page(slug)
    characters = load_characters
    character = characters['characters'][slug]
    return false unless character

    create_character_page(slug, character)
    true
  end

  def build_character_description_text(character)
    text = "Name: #{character['name']}\n"
    text += "Description: #{character['description']}\n"
    text += "Personality Traits: #{character['personality_traits']&.join(', ')}\n" if character['personality_traits']
    text += "Backstory: #{character['backstory']}\n" if character['backstory']
    text += "Quirks: #{character['quirks']}\n" if character['quirks']
    text += "Catchphrase: #{character['catchphrase']}\n" if character['catchphrase']
    text
  end

  def parse_character_improvements(improved_text)
    # Parse improved character text back into structured data
    improvements = {}

    if improved_text.match(/Description:\s*(.+?)(?=\n[A-Z]|\z)/m)
      improvements['description'] =
        ::Regexp.last_match(1).strip
    end

    improvements['backstory'] = ::Regexp.last_match(1).strip if improved_text.match(/Backstory:\s*(.+?)(?=\n[A-Z]|\z)/m)

    improvements['quirks'] = ::Regexp.last_match(1).strip if improved_text.match(/Quirks:\s*(.+?)(?=\n[A-Z]|\z)/m)

    if improved_text.match(/Catchphrase:\s*(.+?)(?=\n[A-Z]|\z)/m)
      improvements['catchphrase'] =
        ::Regexp.last_match(1).strip
    end

    improvements
  end
end
</file>

<file path="scripts/demo_llm.rb">
#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative 'book_utils'
require_relative 'llm_service'
require_relative 'generate_chapter'
require_relative 'manage_characters'

# Demonstration script for LLM-powered content generation
class LLMDemo
  include BookUtils

  def initialize
    @llm_service = LLMService.new
    @chapter_generator = ChapterGenerator.new
    @character_manager = CharacterManager.new
  end

  def run_demo
    puts 'üé≠ One Review Man - LLM Generation Demo'
    puts '=' * 50
    puts ''

    puts 'This demo will show you how to:'
    puts '1. Generate characters with AI'
    puts '2. Generate chapters with AI'
    puts '3. Improve existing content'
    puts '4. Interactive Chat with LLM'
    puts '5. Show Configuration Help'
    puts ''

    puts '‚ö†Ô∏è  Note: If no LLM is configured, mock responses will be used'
    puts ''

    loop do
      show_menu
      choice = gets.chomp.downcase

      case choice
      when '1'
        demo_character_generation
      when '2'
        demo_chapter_generation
      when '3'
        demo_content_improvement
      when '4'
        demo_interactive_chat
      when '5'
        show_configuration_help
      when 'q', 'quit', 'exit'
        puts 'üëã Thanks for trying the LLM demo!'
        break
      else
        puts 'Invalid choice. Please try again.'
      end

      puts "\nPress Enter to continue..."
      gets
    end
  end

  private

  def show_menu
    puts "\nü§ñ LLM Demo Menu"
    puts '-' * 30
    puts '1. Generate Character with AI'
    puts '2. Generate Chapter with AI'
    puts '3. Improve Existing Content'
    puts '4. Interactive Chat with LLM'
    puts '5. Show Configuration Help'
    puts 'Q. Quit'
    puts ''
    print 'Choose an option: '
  end

  def demo_character_generation
    puts "\nüé≠ Character Generation Demo"
    puts '-' * 40

    puts 'Available character types:'
    puts '- hero: Fellow programmers with impressive skills'
    puts '- villain: Bad coders representing poor practices'
    puts '- side: Workplace NPCs for comic relief'
    puts '- mentor: Senior figures with wisdom'
    puts ''
    puts 'üí° NAMING CONVENTIONS:'
    puts '- Characters have professional names (workplace titles) and may have real names'
    puts '- One Review Man (real name: Satoru) - only his disciple uses his real name'
    puts '- AI-Enhanced Disciple (real name: Genki) - Satoru calls him by his real name'
    puts '- Other characters may have both professional and personal names'
    puts ''

    print "Enter character type (or press Enter for 'side'): "
    char_type = gets.chomp
    char_type = 'side' if char_type.empty?

    puts "\nü§ñ Generating #{char_type} character..."

    begin
      character = @character_manager.generate_character(char_type)

      if character
        puts "\n‚úÖ Character Generated Successfully!"
        puts "Name: #{character['name']}"
        puts "Real Name: #{character['real_name']}" if character['real_name'] && character['real_name'] != character['name']
        puts "Description: #{character['description']}"
        puts "Skills: #{character['programming_skills']}"
        puts "Traits: #{character['personality_traits']&.join(', ')}"
        puts "Catchphrase: #{character['catchphrase']}" if character['catchphrase']
        puts ''
        puts "Character saved to _characters/#{character['name'].downcase.gsub(/[^a-z0-9]/, '_')}.md"
      else
        puts '‚ùå Character generation failed'
      end
    rescue StandardError => e
      puts "‚ùå Error: #{e.message}"
    end
  end

  def demo_chapter_generation
    puts "\nüìñ Chapter Generation Demo"
    puts '-' * 40

    book_data = load_book_data('en')
    current_chapter = book_data.dig('book', 'current_chapter') || 0
    next_chapter = current_chapter + 1

    puts "Next chapter to generate: Chapter #{next_chapter}"
    puts ''

    print 'Generate chapter automatically? (y/n): '
    auto = gets.chomp.downcase

    if %w[y yes].include?(auto)
      puts "\nü§ñ Generating Chapter #{next_chapter}..."

      begin
        @chapter_generator.generate_next_chapter(auto_generate: true)
        puts "\n‚úÖ Chapter generation completed!"
        puts 'Check _chapters/ directory for the new chapter file'
      rescue StandardError => e
        puts "‚ùå Error: #{e.message}"
      end
    else
      puts 'Use: ruby scripts/generate_chapter.rb next'
      puts 'This will prompt you through the generation process'
    end
  end

  def demo_content_improvement
    puts "\n‚ú® Content Improvement Demo"
    puts '-' * 40

    puts 'Improvement types:'
    puts '- humor: Make content funnier'
    puts '- clarity: Improve readability and flow'
    puts '- consistency: Ensure consistency with established world'
    puts ''

    # Show available content to improve
    characters = load_characters('en')
    chapters = get_all_chapters('en')

    if characters['characters'].any?
      puts 'Available characters to improve:'
      characters['characters'].each do |slug, char|
        puts "  - #{slug} (#{char['name']})"
      end
      puts ''
    end

    if chapters.any?
      puts 'Available chapters to improve:'
      chapters.each do |chapter|
        puts "  - Chapter #{chapter['chapter_number']}: #{chapter['title']}"
      end
      puts ''
    end

    print 'Improve character or chapter? (character/chapter): '
    content_type = gets.chomp.downcase

    case content_type
    when 'character'
      if characters['characters'].any?
        print 'Enter character slug: '
        slug = gets.chomp

        print 'Improvement type (humor/clarity/consistency): '
        improvement = gets.chomp
        improvement = 'humor' if improvement.empty?

        puts "\nü§ñ Improving character..."
        @character_manager.improve_character(slug, improvement)
      else
        puts 'No characters available to improve'
      end

    when 'chapter'
      if chapters.any?
        print 'Enter chapter number: '
        chapter_num = gets.chomp.to_i

        print 'Improvement type (humor/clarity/consistency): '
        improvement = gets.chomp
        improvement = 'humor' if improvement.empty?

        puts "\nü§ñ Improving chapter..."
        @chapter_generator.improve_chapter(chapter_num, improvement)
      else
        puts 'No chapters available to improve'
      end
    else
      puts 'Invalid content type'
    end
  end

  def demo_interactive_chat
    puts "\nüí¨ Interactive Chat Demo"
    puts '-' * 40
    puts 'Chat with the LLM about One Review Man content'
    puts "Type 'quit' to return to main menu"
    puts ''

    context = "You are discussing 'One Review Man', a programming comedy parody of One-Punch Man. The story follows a super-programmer who writes perfect code and gets all pull requests approved on first review. IMPORTANT NAMING: The protagonist's real name is Satoru (like Saitama), but most people call him 'One Review Man'. His disciple's real name is Genki (like Genos), professional title 'AI-Enhanced Disciple'. Only Genki calls him 'Satoru-sensei', everyone else uses 'One Review Man'. When Satoru and Genki speak privately, they use real names. RUSSIAN TRANSLATION: 'One Review Man' becomes '–í–∞–Ω—Ä–µ–≤—å—é–º–µ–Ω' (like 'One Punch Man' ‚Üí '–í–∞–Ω–ø–∞–Ω—á–º–µ–Ω'), real names become '–°–∞—Ç–æ—Ä—É' and '–ì–µ–Ω–∫–∏'."

    loop do
      print 'You: '
      message = gets.chomp

      break if %w[quit exit back].include?(message.downcase)

      if message.strip.empty?
        puts 'Please enter a message'
        next
      end

      puts "\nü§ñ LLM: "
      begin
        response = @llm_service.chat_with_llm(message, context)
        puts response
      rescue StandardError => e
        puts "‚ùå Error: #{e.message}"
      end
      puts ''
    end
  end

  def show_configuration_help
    puts "\n‚öôÔ∏è  LLM Configuration Help"
    puts '-' * 40

    # Check environment variables first
    env_api_key = ENV.fetch('OPENAI_API_KEY', nil)
    env_org = ENV.fetch('OPENAI_ORG_ID', nil)
    env_project = ENV.fetch('OPENAI_PROJECT_ID', nil)
    env_base_url = ENV.fetch('OPENAI_BASE_URL', nil)

    config_file = 'scripts/llm_config.yml'
    config = {}

    if File.exist?(config_file)
      puts "‚úÖ Configuration file found at: #{config_file}"
      config = begin
        YAML.load_file(config_file)
      rescue StandardError
        {}
      end
    else
      puts "‚ùå No configuration file found at: #{config_file}"
    end

    # Check API key configuration
    if env_api_key
      puts '‚úÖ OpenAI API key found in environment variable'
    elsif config['openai_api_key'] && !config['openai_api_key'].to_s.empty?
      puts '‚ö†Ô∏è  OpenAI API key found in config file (consider using environment variable)'
    else
      puts '‚ùå No OpenAI API key found'
      puts '   Set OPENAI_API_KEY environment variable or add to config file'
    end

    # Show current settings
    puts ''
    puts 'Current settings:'
    puts "  Default Model: #{config['model'] || 'gpt-4o-mini (default)'}"

    # Show task-specific models if configured
    if config['models']
      puts '  Task-specific models:'
      config['models'].each do |task, model|
        puts "    #{task.capitalize}: #{model}"
      end
    end

    puts "  Timeout: #{config['timeout'] || 240} seconds"
    puts "  Max retries: #{config['max_retries'] || 2}"

    puts "  Organization: #{env_org || config['openai_org_id']}" if env_org || config['openai_org_id']

    puts "  Project: #{env_project || config['openai_project_id']}" if env_project || config['openai_project_id']

    puts "  Base URL: #{env_base_url || config['openai_base_url']}" if env_base_url || config['openai_base_url']

    puts ''
    puts 'üîí RECOMMENDED SETUP:'
    puts 'Set environment variables (keeps secrets out of git):'
    puts '  export OPENAI_API_KEY="your-api-key-here"'
    puts '  export OPENAI_ORG_ID="your-org-id"        # optional'
    puts '  export OPENAI_PROJECT_ID="your-project"   # optional'
    puts ''
    puts 'Get your API key from: https://platform.openai.com/api-keys'
    puts ''
    puts 'Available models:'
    puts '  ‚Ä¢ gpt-4o-mini (recommended, fast and cost-effective)'
    puts '  ‚Ä¢ gpt-4o (most capable, higher cost)'
    puts '  ‚Ä¢ gpt-4-turbo (good balance of speed and capability)'
    puts '  ‚Ä¢ gpt-3.5-turbo (fastest and cheapest)'
    puts ''
    puts 'üéØ TASK-SPECIFIC MODELS:'
    puts 'You can now configure different models for different tasks:'
    puts '  ‚Ä¢ Generation (chapters/characters): Use gpt-4o for higher quality content'
    puts '  ‚Ä¢ Translation: Use gpt-4o-mini for fast, cost-effective translation'
    puts '  ‚Ä¢ Chat: Use gpt-4o-mini for quick interactive responses'
    puts ''
    puts 'Edit scripts/llm_config.yml to customize task-specific models and options.'
    puts ''
    puts 'Without API key, the system will use mock responses for development.'
  end
end

# Command line execution
if __FILE__ == $PROGRAM_NAME
  if ARGV[0] == 'setup'
    puts 'üîß Setting up LLM configuration...'

    # Try to create config by running LLM service once
    begin
      LLMService.new
      puts '‚úÖ Example configuration created at scripts/llm_config.yml'
      puts 'Please edit this file with your API keys and preferences'
    rescue StandardError => e
      puts "‚ùå Setup failed: #{e.message}"
    end
  else
    demo = LLMDemo.new
    demo.run_demo
  end
end
</file>

<file path="scripts/llm_config.yml">
# OpenAI Configuration for One Review Man
# ==========================================
#
# SECURITY BEST PRACTICE:
# Set API keys via environment variables instead of this file:
#
#   export OPENAI_API_KEY="your-api-key-here"
#   export OPENAI_ORG_ID="your-org-id"        # optional
#   export OPENAI_PROJECT_ID="your-project"   # optional
#   export OPENAI_BASE_URL="custom-url"       # optional
#
# This keeps secrets out of your repository!

# Alternatively, you can set these in this file (less secure):
# openai_api_key: your-api-key-here
# openai_org_id: your-org-id
# openai_project_id: your-project
# openai_base_url: custom-url

# Default model (used when no task-specific model is specified)
model: gpt-4.1-mini

# Task-specific models (optional)
# You can specify different models for different types of tasks
models:
  # Content generation (chapters, characters, improvements)
  generation: gpt-4.5-preview              # Higher quality for creative writing
  
  # Translation tasks
  translation: gpt-4.1        # Fast and cost-effective for translation
  
  # Chat/interactive tasks
  chat: gpt-4.1-mini              # Quick responses for interactive use

timeout: 240
max_retries: 2
default_options:
  temperature: 0.7
  max_tokens: 2000

# Task-specific options (optional)
task_options:
  generation:
    temperature: 0.8    # More creative for content generation
    max_tokens: 4000    # Longer responses for chapters
  
  translation:
    temperature: 0.3    # More consistent for translation
    max_tokens: 3000    # Adequate for translation tasks
  
  chat:
    temperature: 0.7    # Balanced for conversations
    max_tokens: 2000    # Standard length for chat
</file>

<file path="scripts/llm_service.rb">
#!/usr/bin/env ruby
# frozen_string_literal: true

require 'openai'
require 'yaml'
require 'json'

# LLM Service for generating content via OpenAI API
# This service acts as an abstraction layer that could support multiple providers in the future
class LLMService
  class LLMError < StandardError; end
  class ConfigurationError < LLMError; end
  class APIError < LLMError; end

  DEFAULT_MODEL = 'gpt-4o-mini'

  def initialize(config_file = 'scripts/llm_config.yml')
    @config = load_config(config_file)
    @client = setup_client
  end

  def generate_chapter(prompt, options = {})
    puts 'ü§ñ Generating chapter content...'

    response = call_llm(prompt, get_task_options('generation', {
                                                   max_tokens: 4000,
                                                   temperature: 0.7,
                                                   system_prompt: 'You are a creative writer specializing in programming humor and parody. Write engaging, funny content that captures the absurdist spirit of programming culture.'
                                                 }).merge(options), 'generation')

    raise APIError, 'Failed to generate chapter content' unless response && response['content']

    puts '‚úÖ Chapter generated successfully!'
    response['content']
  end

  def generate_chapter_structured(prompt, options = {})
    puts 'ü§ñ Generating structured chapter content...'

    # Add JSON schema to the prompt
    enhanced_prompt = build_chapter_prompt_with_schema(prompt)

    response = call_llm_structured(enhanced_prompt, get_task_options('generation', {
                                                                       max_tokens: 4000,
                                                                       temperature: 0.7,
                                                                       system_prompt: 'You are a creative writer specializing in programming humor and parody. Write engaging, funny content that captures the absurdist spirit of programming culture. Respond with valid JSON only.',
                                                                       response_format: { type: 'json_object' }
                                                                     }).merge(options), 'generation')

    raise APIError, 'Failed to generate chapter content' unless response && response['content']

    puts '‚úÖ Structured chapter generated successfully!'

    # Handle both JSON string and Hash responses (for mocks)
    begin
      chapter_data = if response['content'].is_a?(Hash)
                       # Mock response is already a hash
                       response['content']
                     else
                       # Real API response is JSON string
                       JSON.parse(response['content'])
                     end

      validate_chapter_data(chapter_data)
      chapter_data
    rescue JSON::ParserError => e
      puts "‚ùå JSON parsing error: #{e.message}"
      puts "Raw response: #{response['content']}"
      # Fallback to old text-based chapter generation
      parse_chapter_content(response['content'])
    end
  end

  def generate_character(prompt, options = {})
    puts 'ü§ñ Generating character...'

    # Add JSON schema to the prompt instead of using unsupported schema parameter
    enhanced_prompt = build_character_prompt_with_schema(prompt)

    # Use structured outputs for reliable character data
    response = call_llm_structured(enhanced_prompt, get_task_options('generation', {
                                                                       max_tokens: 1500,
                                                                       temperature: 0.8,
                                                                       system_prompt: 'You are a character designer for programming comedy stories. Create memorable, funny characters that fit the tech/programming world. Respond with valid JSON only.',
                                                                       response_format: { type: 'json_object' }
                                                                     }).merge(options), 'generation')

    raise APIError, 'Failed to generate character' unless response && response['content']

    puts '‚úÖ Character generated successfully!'

    # Handle both JSON string and Hash responses (for mocks)
    begin
      character_data = if response['content'].is_a?(Hash)
                         # Mock response is already a hash
                         response['content']
                       else
                         # Real API response is JSON string
                         JSON.parse(response['content'])
                       end

      validate_character_data(character_data)
      character_data
    rescue JSON::ParserError => e
      puts "‚ùå JSON parsing error: #{e.message}"
      puts "Raw response: #{response['content']}"
      # Fallback to old parsing method
      parse_character_response(response['content'])
    end
  end

  def improve_content(content, improvement_type, options = {})
    puts "ü§ñ Improving content (#{improvement_type})..."

    system_prompts = {
      'humor' => 'You are an expert comedy writer. Make the content funnier while maintaining its core message.',
      'clarity' => 'You are an expert editor. Improve the clarity and flow of the content while maintaining its style.',
      'consistency' => 'You are an expert continuity editor. Ensure the content is consistent with established characters and world-building.'
    }

    prompt = build_improvement_prompt(content, improvement_type)

    response = call_llm(prompt, get_task_options('generation', {
                                                   max_tokens: 3000,
                                                   temperature: 0.6,
                                                   system_prompt: system_prompts[improvement_type] || system_prompts['clarity']
                                                 }).merge(options), 'generation')

    raise APIError, 'Failed to improve content' unless response && response['content']

    puts '‚úÖ Content improved successfully!'
    response['content']
  end

  def chat_with_llm(message, context = nil, options = {})
    puts 'ü§ñ Processing request...'

    prompt = context ? "#{context}\n\nUser: #{message}" : message

    response = call_llm(prompt, get_task_options('chat', {
                                                   max_tokens: 2000,
                                                   temperature: 0.7
                                                 }).merge(options), 'chat')

    raise APIError, 'Failed to get response from LLM' unless response && response['content']

    response['content']
  end

  def translate_chapter_structured(title, summary, content, target_lang)
    puts "ü§ñ Translating chapter to #{target_lang}..."

    # Build translation prompt with schema
    prompt = build_chapter_translation_prompt(title, summary, content, target_lang)

    response = call_llm_structured(prompt, get_task_options('translation', {
                                                              max_tokens: 4000,
                                                              temperature: 0.3, # Lower temperature for more consistent translation
                                                              system_prompt: 'You are a professional translator specializing in programming humor and technical content. Translate accurately while preserving the comedy and technical references. Respond with valid JSON only.',
                                                              response_format: { type: 'json_object' }
                                                            }), 'translation')

    raise APIError, 'Failed to translate chapter' unless response && response['content']

    puts '‚úÖ Chapter translation completed!'

    # Handle both JSON string and Hash responses
    begin
      translation_data = if response['content'].is_a?(Hash)
                           response['content']
                         else
                           JSON.parse(response['content'])
                         end

      validate_chapter_translation_data(translation_data)
      translation_data
    rescue JSON::ParserError => e
      puts "‚ùå JSON parsing error: #{e.message}"
      puts "Raw response: #{response['content']}"
      # Fallback to simple translation
      fallback_chapter_translation(title, summary, content, target_lang)
    end
  end

  def translate_character_structured(name, description, personality_traits, programming_skills, catchphrase, backstory,
                                     quirks, target_lang)
    puts "ü§ñ Translating character to #{target_lang}..."

    # Build translation prompt with schema
    prompt = build_character_translation_prompt(name, description, personality_traits, programming_skills, catchphrase,
                                                backstory, quirks, target_lang)

    response = call_llm_structured(prompt, get_task_options('translation', {
                                                              max_tokens: 2000,
                                                              temperature: 0.3, # Lower temperature for more consistent translation
                                                              system_prompt: 'You are a professional translator specializing in programming humor and character development. Translate character details accurately while preserving personality and humor. Respond with valid JSON only.',
                                                              response_format: { type: 'json_object' }
                                                            }), 'translation')

    raise APIError, 'Failed to translate character' unless response && response['content']

    puts '‚úÖ Character translation completed!'

    # Handle both JSON string and Hash responses
    begin
      translation_data = if response['content'].is_a?(Hash)
                           response['content']
                         else
                           JSON.parse(response['content'])
                         end

      validate_character_translation_data(translation_data)
      translation_data
    rescue JSON::ParserError => e
      puts "‚ùå JSON parsing error: #{e.message}"
      puts "Raw response: #{response['content']}"
      # Fallback to simple translation
      fallback_character_translation(name, description, personality_traits, programming_skills, catchphrase, backstory,
                                     quirks, target_lang)
    end
  end

  private

  def load_config(config_file)
    if File.exist?(config_file)
      YAML.load_file(config_file) || {}
    else
      puts "‚ö†Ô∏è  LLM config file not found at #{config_file}"
      puts 'Creating example config file...'
      create_example_config(config_file)
      {}
    end
  end

  def setup_client
    # Use environment variables first (recommended), then fall back to config
    api_key = ENV['OPENAI_API_KEY'] || @config['openai_api_key']
    organization = ENV['OPENAI_ORG_ID'] || @config['openai_org_id']
    ENV['OPENAI_PROJECT_ID'] || @config['openai_project_id']
    base_url = ENV['OPENAI_BASE_URL'] || @config['openai_base_url']

    unless api_key
      puts '‚ö†Ô∏è  No OpenAI API key found in environment or config. Using mock responses...'
      puts "Set OPENAI_API_KEY environment variable or add 'openai_api_key' to config file"
      return nil
    end

    # Initialize client with correct parameters for ruby-openai gem
    client_options = {
      access_token: api_key, # ruby-openai uses access_token, not api_key
      log_errors: true # Helpful for development
    }

    # Add optional parameters if present - using ruby-openai parameter names
    client_options[:organization_id] = organization if organization
    # NOTE: ruby-openai gem doesn't support project parameter
    client_options[:uri_base] = base_url if base_url
    client_options[:request_timeout] = @config['timeout'] || 240

    OpenAI::Client.new(**client_options)
  end

  def call_llm(prompt, options = {}, task_type = 'generation')
    if @client.nil?
      puts '‚ö†Ô∏è  No OpenAI client configured. Using mock response for development...'
      return mock_response(prompt)
    end

    model = get_model_for_task(task_type)

    messages = []
    messages << { role: 'system', content: options[:system_prompt] } if options[:system_prompt]
    messages << { role: 'user', content: prompt }

    parameters = {
      model: model,
      messages: messages,
      max_tokens: options[:max_tokens] || 2000,
      temperature: options[:temperature] || 0.7
    }

    begin
      response = @client.chat(parameters: parameters)

      content = response.dig('choices', 0, 'message', 'content')
      { 'content' => content }
    rescue Faraday::Error => e
      puts e.backtrace.join("\n")
      puts "‚ùå API Error: #{e.message}"
      puts 'Returning mock response for development...'
      mock_response(prompt)
    rescue StandardError => e
      puts e.backtrace.join("\n")
      puts "‚ùå Unexpected Error: #{e.message}"
      puts 'Returning mock response for development...'
      mock_response(prompt)
    end
  end

  def call_llm_structured(prompt, options = {}, task_type = 'generation')
    if @client.nil?
      puts '‚ö†Ô∏è  No OpenAI client configured. Using mock response for development...'
      return mock_response(prompt)
    end

    model = get_model_for_task(task_type)

    messages = []
    messages << { role: 'system', content: options[:system_prompt] } if options[:system_prompt]
    messages << { role: 'user', content: prompt }

    parameters = {
      model: model,
      messages: messages,
      max_tokens: options[:max_tokens] || 2000,
      temperature: options[:temperature] || 0.7,
      response_format: options[:response_format]
    }

    begin
      response = @client.chat(parameters: parameters)

      content = response.dig('choices', 0, 'message', 'content')
      { 'content' => content }
    rescue Faraday::Error => e
      puts e.backtrace.join("\n")
      puts "‚ùå API Error: #{e.message}"
      puts 'Returning mock response for development...'
      mock_response(prompt)
    rescue StandardError => e
      puts e.backtrace.join("\n")
      puts "‚ùå Unexpected Error: #{e.message}"
      puts 'Returning mock response for development...'
      mock_response(prompt)
    end
  end

  def mock_response(prompt)
    puts 'üé≠ Using mock response (OpenAI not configured)'

    if prompt.include?('Chapter') || prompt.include?('chapter')
      {
        'content' => generate_mock_chapter
      }
    elsif prompt.include?('character') || prompt.include?('Character')
      {
        'content' => generate_mock_character
      }
    else
      {
        'content' => "This is a mock response to your request: #{prompt[0..100]}..."
      }
    end
  end

  def generate_mock_chapter
    <<~CHAPTER
      # The Great Code Review Catastrophe

      One Review Man sat at his desk, fingers hovering over the keyboard like a pianist about to perform his masterpiece. Another pull request had been submitted to the company's critical payment processing system, and panic was spreading through the engineering floor like a poorly written recursive function.

      "This is impossible!" shouted the Senior Developer, frantically scrolling through 2,847 lines of spaghetti code. "The deadline is in two hours, and this code looks like it was written by a caffeinated intern during a hackathon!"

      The AI-Enhanced Disciple rolled up to One Review Man's desk, his neural interface flickering with anxiety. "Master, the production deployment is scheduled in 120 minutes. Even you couldn't review this disaster in time!"

      One Review Man cracked his knuckles‚Äîa sound that sent shivers down the spines of junior developers within a 20-foot radius. "Stand back," he said simply.

      His eyes began to glow with the ethereal light of perfect code comprehension. In exactly 3.7 seconds, he had:
      - Identified 47 critical bugs
      - Spotted 12 security vulnerabilities#{'  '}
      - Found 23 performance bottlenecks
      - Detected 156 code style violations
      - Discovered that the entire authentication system was backwards

      "APPROVED AND MERGED," he announced, having simultaneously fixed every issue with a single, transcendent commit.

      The office fell silent. Even the coffee machine stopped brewing.

      "But Master," whispered the AI-Enhanced Disciple, "how did you know the authentication bug was there? It was hidden behind three layers of abstraction!"

      One Review Man turned slowly, his expression as blank as a freshly formatted hard drive. "When you write 100 pull requests, 100 code reviews, and run 10 kilometers of test suites every single day for three years... you become able to debug anything with just one glance."

      Thunder rumbled in the distance‚Äîor maybe it was just the sound of their AWS bill doubling.
    CHAPTER
  end

  def generate_mock_character
    {
      'name' => 'The Framework Fanatic',
      'description' => 'A developer obsessed with using the latest JavaScript framework for everything, including microwave programming.',
      'personality_traits' => ['Overly enthusiastic', 'Buzzword-heavy', 'Framework evangelist'],
      'catchphrase' => "Have you heard about the new framework that just dropped? It's going to revolutionize everything!",
      'backstory' => 'Former jQuery developer who discovered React and never looked back. Currently advocating for rewriting the coffee machine interface in Vue.js.',
      'quirks' => 'Speaks only in npm package names when stressed.'
    }
  end

  def parse_character_response(response)
    # Handle mock responses (which are already hashes)
    return response if response.is_a?(Hash)

    # Try to extract structured character data from string response
    # This is a simple parser - could be enhanced based on actual LLM output format

    lines = response.split("\n").reject(&:empty?)
    character = {}

    current_section = nil
    content_buffer = []

    lines.each do |line|
      if line.match(/^(Name|Description|Personality|Traits|Catchphrase|Backstory|Quirks):/i)
        # Save previous section
        character[current_section] = content_buffer.join(' ').strip if current_section && content_buffer.any?

        # Start new section
        parts = line.split(':', 2)
        current_section = parts[0].downcase.gsub(/\s+/, '_')
        content_buffer = [parts[1].to_s.strip]
      elsif current_section
        content_buffer << line.strip
      end
    end

    # Save last section
    character[current_section] = content_buffer.join(' ').strip if current_section && content_buffer.any?

    # Convert traits to array if it's a string
    if character['personality_traits'].is_a?(String)
      character['personality_traits'] = character['personality_traits'].split(',').map(&:strip)
    end

    character
  end

  def build_improvement_prompt(content, improvement_type)
    case improvement_type
    when 'humor'
      "Please make the following content funnier while maintaining its core message and story progression:\n\n#{content}"
    when 'clarity'
      "Please improve the clarity and flow of the following content while maintaining its humor and style:\n\n#{content}"
    when 'consistency'
      "Please review the following content for consistency with established characters and world-building, and make any necessary adjustments:\n\n#{content}"
    else
      "Please improve the following content:\n\n#{content}"
    end
  end

  def create_example_config(config_file)
    # Create clean config hash with task-specific models
    clean_config = {
      'model' => 'gpt-4o-mini',
      'models' => {
        'generation' => 'gpt-4o',
        'translation' => 'gpt-4o-mini',
        'chat' => 'gpt-4o-mini'
      },
      'timeout' => 240,
      'max_retries' => 2,
      'default_options' => {
        'temperature' => 0.7,
        'max_tokens' => 2000
      },
      'task_options' => {
        'generation' => {
          'temperature' => 0.8,
          'max_tokens' => 4000
        },
        'translation' => {
          'temperature' => 0.3,
          'max_tokens' => 3000
        },
        'chat' => {
          'temperature' => 0.7,
          'max_tokens' => 2000
        }
      }
    }

    File.open(config_file, 'w') do |file|
      file.puts '# OpenAI Configuration for One Review Man'
      file.puts '# =========================================='
      file.puts '#'
      file.puts '# SECURITY BEST PRACTICE:'
      file.puts '# Set API keys via environment variables instead of this file:'
      file.puts '#'
      file.puts '#   export OPENAI_API_KEY="your-api-key-here"'
      file.puts '#   export OPENAI_ORG_ID="your-org-id"        # optional'
      file.puts '#   export OPENAI_PROJECT_ID="your-project"   # optional'
      file.puts '#   export OPENAI_BASE_URL="custom-url"       # optional'
      file.puts '#'
      file.puts '# This keeps secrets out of your repository!'
      file.puts ''
      file.puts '# Alternatively, you can set these in this file (less secure):'
      file.puts '# openai_api_key: your-api-key-here'
      file.puts '# openai_org_id: your-org-id'
      file.puts '# openai_project_id: your-project'
      file.puts '# openai_base_url: custom-url'
      file.puts ''
      file.puts '# Default model (used when no task-specific model is specified)'
      file.puts clean_config.to_yaml.lines[1..].join # Skip first "---" line
    end

    puts "üìù Created example config at #{config_file}"
    puts ''
    puts 'üîí SECURITY RECOMMENDATION:'
    puts 'Set your API key via environment variable instead of config file:'
    puts '  export OPENAI_API_KEY="your-api-key-here"'
    puts ''
    puts 'Get your API key from: https://platform.openai.com/api-keys'
    puts ''
    puts 'Available models:'
    puts '  - gpt-4o-mini (recommended, fast and cost-effective)'
    puts '  - gpt-4o (most capable)'
    puts '  - gpt-4-turbo (good balance)'
    puts '  - gpt-3.5-turbo (fastest, cheapest)'
    puts ''
    puts 'Task-specific models configured:'
    puts '  - Generation (chapters/characters): gpt-4o (higher quality)'
    puts '  - Translation: gpt-4o-mini (fast and cost-effective)'
    puts '  - Chat: gpt-4o-mini (quick responses)'
    puts ''
    puts 'Environment variables supported:'
    puts '  - OPENAI_API_KEY (required)'
    puts '  - OPENAI_ORG_ID (optional)'
    puts '  - OPENAI_PROJECT_ID (optional)'
    puts '  - OPENAI_BASE_URL (optional)'
  end

  def character_schema
    {
      type: 'object',
      properties: {
        name: {
          type: 'string',
          description: 'Character name'
        },
        description: {
          type: 'string',
          description: 'Brief character description'
        },
        personality_traits: {
          type: 'array',
          items: { type: 'string' },
          description: 'List of personality traits'
        },
        programming_skills: {
          type: 'string',
          description: 'Programming abilities and technical skills'
        },
        catchphrase: {
          type: 'string',
          description: 'Character catchphrase or motto'
        },
        backstory: {
          type: 'string',
          description: 'Character background story'
        },
        quirks: {
          type: 'string',
          description: 'Notable quirks or unique characteristics'
        }
      },
      required: %w[name description personality_traits programming_skills],
      additionalProperties: false
    }
  end

  def validate_character_data(data)
    required_fields = %w[name description personality_traits programming_skills]

    missing_fields = required_fields.select { |field| data[field].nil? || data[field].to_s.strip.empty? }

    raise APIError, "Missing required character fields: #{missing_fields.join(', ')}" if missing_fields.any?

    # Ensure personality_traits is an array
    unless data['personality_traits'].is_a?(Array)
      raise APIError, "personality_traits must be an array, got: #{data['personality_traits'].class}"
    end

    # Ensure name is not empty
    raise APIError, 'Character name cannot be empty' if data['name'].to_s.strip.empty?

    puts '‚úÖ Character data validation passed'
    true
  end

  def build_character_prompt_with_schema(prompt)
    schema_description = <<~SCHEMA

      IMPORTANT: Respond with valid JSON that matches this exact schema:

      {
        "name": "Professional/workplace name (string)",
        "real_name": "Actual given name (string, optional - include if different from professional name)",
        "description": "Brief character description (string)",
        "personality_traits": ["trait1", "trait2", "trait3"],
        "programming_skills": "Programming abilities and technical skills (string)",
        "catchphrase": "Character catchphrase or motto (string, optional)",
        "backstory": "Character background story (string, optional)",
        "quirks": "Notable quirks or unique characteristics (string, optional)"
      }

      Required fields: name, description, personality_traits, programming_skills
      Optional fields: real_name, catchphrase, backstory, quirks

      NAMING CONVENTIONS:
      - For One Review Man: name="One Review Man", real_name="Satoru"
      - For AI-Enhanced Disciple: name="AI-Enhanced Disciple", real_name="Genki"#{'  '}
      - For other characters: include real_name only if they have both professional and personal names

      Make sure personality_traits is always an array of strings.
    SCHEMA

    "#{prompt}#{schema_description}"
  end

  def build_chapter_prompt_with_schema(prompt)
    schema_description = <<~SCHEMA

      IMPORTANT: Respond with valid JSON that matches this exact schema:

      {
        "title": "Chapter title (string)",
        "content": "Chapter content in markdown format (string)",
        "summary": "Brief chapter summary (string)",
        "new_characters": [
          {
            "name": "Character name",
            "description": "Brief character description"
          }
        ],
        "programming_themes": ["code_review", "debugging", "deployment", "meetings"],
        "comedy_elements": ["absurd_situation", "tech_parody", "workplace_humor"],
        "word_count": 1500,
        "difficulty_level": "beginner",
        "one_punch_man_references": ["reference1", "reference2"]
      }

      Required fields: title, content, summary
      Optional but recommended: new_characters, programming_themes, comedy_elements, word_count, difficulty_level, one_punch_man_references

      Programming themes can include: code_review, debugging, deployment, git_conflicts, meetings, technical_debt, framework_wars, stack_overflow, pair_programming, devops
      Comedy elements can include: absurd_situation, tech_parody, workplace_humor, overpowered_protagonist, bureaucracy_satire
      Difficulty levels: beginner, intermediate, advanced

      Make sure content is engaging programming comedy that parodies One-Punch Man tropes.
    SCHEMA

    "#{prompt}#{schema_description}"
  end

  def validate_chapter_data(data)
    required_fields = %w[title content summary]

    missing_fields = required_fields.select { |field| data[field].nil? || data[field].to_s.strip.empty? }

    raise APIError, "Missing required chapter fields: #{missing_fields.join(', ')}" if missing_fields.any?

    # Ensure title is not empty
    raise APIError, 'Chapter title cannot be empty' if data['title'].to_s.strip.empty?

    # Validate optional arrays
    %w[new_characters programming_themes comedy_elements one_punch_man_references].each do |field|
      if data[field] && !data[field].is_a?(Array)
        puts "‚ö†Ô∏è  Warning: #{field} should be an array, got #{data[field].class}"
      end
    end

    # Validate word count if present
    puts '‚ö†Ô∏è  Warning: word_count should be an integer' if data['word_count'] && !data['word_count'].is_a?(Integer)

    puts '‚úÖ Chapter data validation passed'
    true
  end

  def parse_chapter_content(content)
    # Handle mock responses (which are already hashes)
    return content if content.is_a?(Hash)

    # Try to extract structured chapter data from string response
    # This is a simple parser - could be enhanced based on actual LLM output format

    lines = content.split("\n").reject(&:empty?)
    chapter = {}

    current_section = nil
    content_buffer = []

    lines.each do |line|
      if line.match(/^(Title|Content|Summary|Metadata):/i)
        # Save previous section
        chapter[current_section] = content_buffer.join(' ').strip if current_section && content_buffer.any?

        # Start new section
        parts = line.split(':', 2)
        current_section = parts[0].downcase.gsub(/\s+/, '_')
        content_buffer = [parts[1].to_s.strip]
      elsif current_section
        content_buffer << line.strip
      end
    end

    # Save last section
    chapter[current_section] = content_buffer.join(' ').strip if current_section && content_buffer.any?

    # Convert metadata to hash if it's a string
    chapter['metadata'] = JSON.parse(chapter['metadata']) if chapter['metadata'].is_a?(String)

    chapter
  end

  def build_chapter_translation_prompt(title, summary, content, target_lang)
    language_names = {
      'ru' => 'Russian',
      'es' => 'Spanish',
      'fr' => 'French',
      'de' => 'German',
      'zh' => 'Chinese'
    }

    target_language_name = language_names[target_lang] || target_lang.upcase

    # Special handling for Russian transliterations
    special_instructions = ''
    if target_lang == 'ru'
      special_instructions = <<~RUSSIAN_INSTRUCTIONS

        RUSSIAN TRANSLITERATION RULES:
        - "One Review Man" ‚Üí "–í–∞–Ω—Ä–µ–≤—å—é–º–µ–Ω" (follows the same pattern as "One Punch Man" ‚Üí "–í–∞–Ω–ø–∞–Ω—á–º–µ–Ω")
        - "AI-Enhanced Disciple" ‚Üí "–ò–ò-–£—Å–∏–ª–µ–Ω–Ω—ã–π –£—á–µ–Ω–∏–∫"
        - Keep real names in Japanese style: "Satoru" ‚Üí "–°–∞—Ç–æ—Ä—É", "Genki" ‚Üí "–ì–µ–Ω–∫–∏"
        - Use respectful address: "–°–∞—Ç–æ—Ä—É-—Å–µ–Ω—Å–µ–π" for "Satoru-sensei"
        - Programming terms: mix English and Russian naturally (e.g., "–ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç", "–∫–æ–¥", but "pull request", "git")
      RUSSIAN_INSTRUCTIONS
    end

    prompt = <<~PROMPT
      Translate the following programming comedy chapter from English to #{target_language_name}.

      PRESERVE:
      - Programming humor and technical jokes
      - One-Punch Man parody references#{'  '}
      - Character personalities and catchphrases
      - Markdown formatting
      - Technical terms (translate context, keep some English technical terms where appropriate)
      - Naming conventions and character address patterns
      #{special_instructions}

      SOURCE CHAPTER:
      Title: #{title}
      Summary: #{summary}

      Content:
      #{content}

      TRANSLATION INSTRUCTIONS:
      - Translate all narrative text to #{target_language_name}
      - Keep programming terms in English where commonly used (e.g., "pull request", "merge", "deployment")
      - Adapt jokes to work in #{target_language_name} while keeping the programming humor
      - Maintain the One-Punch Man parody style
      - Follow character naming and address conventions for #{target_language_name}
    PROMPT

    schema_description = <<~SCHEMA

      IMPORTANT: Respond with valid JSON that matches this exact schema:

      {
        "title": "Translated chapter title (string)",
        "summary": "Translated chapter summary (string)",
        "content": "Translated chapter content in markdown format (string)"
      }

      Required fields: title, summary, content
      All fields should contain the translated text in #{target_language_name}.
    SCHEMA

    "#{prompt}#{schema_description}"
  end

  def validate_chapter_translation_data(data)
    required_fields = %w[title summary content]

    missing_fields = required_fields.select { |field| data[field].nil? || data[field].to_s.strip.empty? }

    raise APIError, "Missing required chapter translation fields: #{missing_fields.join(', ')}" if missing_fields.any?

    # Ensure title is not empty
    raise APIError, 'Chapter title cannot be empty' if data['title'].to_s.strip.empty?

    puts '‚úÖ Chapter translation data validation passed'
    true
  end

  def fallback_chapter_translation(_title, _summary, _content, _target_lang)
    # Implement fallback translation logic here
    # This is a placeholder and should be replaced with actual implementation
    puts '‚ùå Fallback translation not implemented'
    {}
  end

  def build_character_translation_prompt(name, description, personality_traits, programming_skills, catchphrase,
                                         backstory, quirks, target_lang)
    language_names = {
      'ru' => 'Russian',
      'es' => 'Spanish',
      'fr' => 'French',
      'de' => 'German',
      'zh' => 'Chinese'
    }

    target_language_name = language_names[target_lang] || target_lang.upcase

    # Special handling for Russian transliterations
    special_instructions = ''
    if target_lang == 'ru'
      special_instructions = <<~RUSSIAN_INSTRUCTIONS

        RUSSIAN TRANSLITERATION RULES:
        - "One Review Man" ‚Üí "–í–∞–Ω—Ä–µ–≤—å—é–º–µ–Ω" (follows the same pattern as "One Punch Man" ‚Üí "–í–∞–Ω–ø–∞–Ω—á–º–µ–Ω")
        - "AI-Enhanced Disciple" ‚Üí "–ò–ò-–£—Å–∏–ª–µ–Ω–Ω—ã–π –£—á–µ–Ω–∏–∫"
        - Keep real names in Japanese style: "Satoru" ‚Üí "–°–∞—Ç–æ—Ä—É", "Genki" ‚Üí "–ì–µ–Ω–∫–∏"
        - Use respectful address: "–°–∞—Ç–æ—Ä—É-—Å–µ–Ω—Å–µ–π" for "Satoru-sensei"
        - For other characters: translate descriptive titles, transliterate personal names
        - Programming terms: mix English and Russian naturally (e.g., "–ø—Ä–æ–≥—Ä–∞–º–º–∏—Å—Ç", "–∫–æ–¥", but "pull request", "git")
      RUSSIAN_INSTRUCTIONS
    end

    prompt = <<~PROMPT
      Translate the following programming comedy character from English to #{target_language_name}.

      PRESERVE:
      - Programming humor and personality
      - Technical skills and abilities
      - Character quirks and comedy elements
      - Programming-related catchphrases
      - Character naming conventions and address patterns
      #{special_instructions}

      SOURCE CHARACTER:
      Name: #{name}
      Description: #{description}
      Personality Traits: #{personality_traits.join(', ')}
      Programming Skills: #{programming_skills}
      Catchphrase: #{catchphrase}
      Backstory: #{backstory}
      Quirks: #{quirks}

      TRANSLATION INSTRUCTIONS:
      - Translate all descriptive text to #{target_language_name}
      - Keep programming terms in English where commonly used
      - Adapt humor to work in #{target_language_name} while keeping the programming context
      - Maintain character personality and comedy style
      - Follow character naming conventions for #{target_language_name}
      - Preserve the relationship dynamic with other characters (especially One Review Man/–í–∞–Ω—Ä–µ–≤—å—é–º–µ–Ω)
    PROMPT

    schema_description = <<~SCHEMA

      IMPORTANT: Respond with valid JSON that matches this exact schema:

      {
        "name": "Translated character name (string)",
        "description": "Translated character description (string)",
        "personality_traits": ["translated_trait1", "translated_trait2", "translated_trait3"],
        "programming_skills": "Translated programming abilities and technical skills (string)",
        "catchphrase": "Translated character catchphrase or motto (string, optional)",
        "backstory": "Translated character background story (string, optional)",
        "quirks": "Translated notable quirks or unique characteristics (string, optional)"
      }

      Required fields: name, description, personality_traits, programming_skills
      Optional fields: catchphrase, backstory, quirks
      All fields should contain translated text in #{target_language_name}.
      Make sure personality_traits is always an array of strings.
    SCHEMA

    "#{prompt}#{schema_description}"
  end

  def validate_character_translation_data(data)
    required_fields = %w[name description personality_traits programming_skills]

    missing_fields = required_fields.select { |field| data[field].nil? || data[field].to_s.strip.empty? }

    raise APIError, "Missing required character translation fields: #{missing_fields.join(', ')}" if missing_fields.any?

    # Ensure personality_traits is an array
    unless data['personality_traits'].is_a?(Array)
      raise APIError, "personality_traits must be an array, got: #{data['personality_traits'].class}"
    end

    # Ensure name is not empty
    raise APIError, 'Character name cannot be empty' if data['name'].to_s.strip.empty?

    puts '‚úÖ Character translation data validation passed'
    true
  end

  def fallback_character_translation(_name, _description, _personality_traits, _programming_skills, _catchphrase, _backstory,
                                     _quirks, _target_lang)
    # Implement fallback translation logic here
    # This is a placeholder and should be replaced with actual implementation
    puts '‚ùå Fallback translation not implemented'
    {}
  end

  # Get task-specific configuration options
  def get_task_options(task_type, base_options = {})
    # Start with default options
    merged_options = (@config['default_options'] || {}).dup

    # Override with task-specific options if they exist
    if @config['task_options'] && @config['task_options'][task_type]
      merged_options.merge!(@config['task_options'][task_type])
    end

    # Finally merge with any provided base options (method-level defaults)
    merged_options.merge!(base_options)

    # Convert string keys to symbol keys for consistency
    merged_options.transform_keys(&:to_sym)
  end

  # Get model for specific task type
  def get_model_for_task(task_type)
    # Try task-specific model first
    if @config['models'] && @config['models'][task_type]
      @config['models'][task_type]
    else
      # Fall back to default model
      @config['model'] || DEFAULT_MODEL
    end
  end
end
</file>

<file path="scripts/reset_book.rb">
#!/usr/bin/env ruby
# frozen_string_literal: true

require 'yaml'
require 'fileutils'
require_relative 'book_utils'

class BookReset
  include BookUtils

  def initialize
    @dry_run = false
  end

  def reset_all(force: false)
    puts 'üîÑ Book Reset Tool'
    puts '=' * 50

    unless force
      puts '‚ö†Ô∏è  WARNING: This will delete ALL book content!'
      puts ''
      puts 'This action will:'
      puts '- Remove all character files and data'
      puts '- Remove all chapter files'
      puts '- Reset all _data/*.yml files to initial state'
      puts '- Clear generation logs'
      puts ''
      print "Are you absolutely sure? Type 'RESET' to confirm: "

      confirmation = gets.chomp
      unless confirmation == 'RESET'
        puts '‚ùå Reset cancelled.'
        return false
      end
    end

    puts "\nüßπ Starting book reset..."

    success = true
    success &= reset_characters
    success &= reset_chapters
    success &= reset_data_files
    success &= reset_generated_site

    if success
      puts "\n‚úÖ Book reset completed successfully!"
      puts 'üìù The book is now in its initial empty state.'
    else
      puts "\n‚ùå Some errors occurred during reset."
    end

    success
  end

  def reset_characters(force: false)
    unless force
      puts "\nüìä Character Reset Preview:"
      character_files = Dir.glob('_characters/*.md')
      if character_files.empty?
        puts '  No character files found.'
        return true # Nothing to reset
      else
        puts '  Files to be deleted:'
        character_files.each { |f| puts "    - #{f}" }
      end

      print "\nProceed with character reset? (y/N): "
      begin
        response = $stdin.gets&.chomp&.downcase || 'n'
        unless response.start_with?('y')
          puts '‚ùå Character reset cancelled.'
          return false
        end
      rescue StandardError => e
        puts "‚ùå Input error: #{e.message}"
        puts '‚ùå Character reset cancelled.'
        return false
      end
    end

    puts "\nüé≠ Resetting characters..."

    # Remove character files
    character_files = Dir.glob('_characters/*.md')
    character_files.each do |file|
      File.delete(file)
      puts "  üóëÔ∏è  Deleted: #{file}"
    end

    # Reset characters.yml
    reset_characters_yml

    puts '‚úÖ Characters reset completed.'
    true
  rescue StandardError => e
    puts "‚ùå Error resetting characters: #{e.message}"
    false
  end

  def reset_chapters(force: false)
    unless force
      puts "\nüìä Chapter Reset Preview:"
      chapter_files = Dir.glob('_chapters/*.md')
      if chapter_files.empty?
        puts '  No chapter files found.'
        return true # Nothing to reset
      else
        puts '  Files to be deleted:'
        chapter_files.each { |f| puts "    - #{f}" }
      end

      print "\nProceed with chapter reset? (y/N): "
      begin
        response = $stdin.gets&.chomp&.downcase || 'n'
        unless response.start_with?('y')
          puts '‚ùå Chapter reset cancelled.'
          return false
        end
      rescue StandardError => e
        puts "‚ùå Input error: #{e.message}"
        puts '‚ùå Chapter reset cancelled.'
        return false
      end
    end

    puts "\nüìö Resetting chapters..."

    # Remove chapter files
    chapter_files = Dir.glob('_chapters/*.md')
    chapter_files.each do |file|
      File.delete(file)
      puts "  üóëÔ∏è  Deleted: #{file}"
    end

    puts '‚úÖ Chapters reset completed.'
    true
  rescue StandardError => e
    puts "‚ùå Error resetting chapters: #{e.message}"
    false
  end

  def reset_data_files
    puts "\nüíæ Resetting data files..."

    reset_book_metadata_yml
    reset_characters_yml
    reset_generation_log_yml

    puts '‚úÖ Data files reset completed.'
    true
  rescue StandardError => e
    puts "‚ùå Error resetting data files: #{e.message}"
    false
  end

  def reset_generated_site
    puts "\nüåê Cleaning generated site..."

    # Clean Jekyll cache
    if Dir.exist?('.jekyll-cache')
      FileUtils.rm_rf('.jekyll-cache')
      puts '  üóëÔ∏è  Deleted: .jekyll-cache/'
    end

    # Clean _site directory
    if Dir.exist?('_site')
      FileUtils.rm_rf('_site')
      puts '  üóëÔ∏è  Deleted: _site/'
    end

    puts '‚úÖ Generated site cleanup completed.'
    true
  rescue StandardError => e
    puts "‚ùå Error cleaning generated site: #{e.message}"
    false
  end

  def status
    puts 'üìä Book Status'
    puts '=' * 30

    # Characters
    character_files = Dir.glob('_characters/*.md')
    characters_data = load_characters
    char_count = characters_data['characters']&.size || 0

    puts 'Characters:'
    puts "  üìÑ Files: #{character_files.size}"
    puts "  üíæ In YAML: #{char_count}"

    # Chapters
    chapter_files = Dir.glob('_chapters/*.md')
    chapters_data = get_all_chapters

    puts "\nChapters:"
    puts "  üìÑ Files: #{chapter_files.size}"
    puts "  üìñ Parsed: #{chapters_data.size}"

    # Data files
    puts "\nData Files:"
    %w[book_metadata.yml characters.yml generation_log.yml strings.yml].each do |file|
      path = File.join('_data', file)
      status = File.exist?(path) ? '‚úÖ Exists' : '‚ùå Missing'
      puts "  #{file}: #{status}"
    end

    # Generated content
    puts "\nGenerated Content:"
    puts "  .jekyll-cache: #{Dir.exist?('.jekyll-cache') ? '‚úÖ Exists' : '‚ùå Missing'}"
    puts "  _site: #{Dir.exist?('_site') ? '‚úÖ Exists' : '‚ùå Missing'}"
  end

  private

  def reset_book_metadata_yml
    initial_data = {
      'en' => {
        'book' => {
          'title' => 'One Review Man',
          'subtitle' => 'An AI-Generated Comedy of Errors',
          'author' => 'AI Collective',
          'genre' => 'Humor/Comedy',
          'target_chapters' => 50,
          'current_chapter' => 0
        },
        'generation' => {
          'model' => 'gpt-4.1',
          'chapter_length_target' => '1500-3000 words',
          'humor_style' => 'absurdist',
          'complexity_level' => 'medium',
          'character_consistency' => true
        },
        'themes' => {
          'primary' => 'workplace comedy',
          'secondary' => [
            'mistaken identity',
            'bureaucratic absurdity',
            'everyday situations gone wrong'
          ]
        },
        'status' => {
          'last_generated' => nil,
          'generation_count' => 0,
          'characters_created' => 0,
          'active_storylines' => [],
          'chapters_written' => 0
        }
      },
      'ru' => {
        'book' => {
          'title' => '–í–∞–Ω—Ä–µ–≤—å—é–º—ç–Ω',
          'subtitle' => '–ò–ò-–≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º–∞—è –ö–æ–º–µ–¥–∏—è –û—à–∏–±–æ–∫',
          'author' => '–ò–ò –ö–æ–ª–ª–µ–∫—Ç–∏–≤',
          'genre' => '–Æ–º–æ—Ä/–ö–æ–º–µ–¥–∏—è',
          'target_chapters' => 50,
          'current_chapter' => 0
        },
        'generation' => {
          'model' => 'gpt-4.1',
          'chapter_length_target' => '1500-3000 —Å–ª–æ–≤',
          'humor_style' => '–∞–±—Å—É—Ä–¥–∏—Å—Ç—Å–∫–∏–π',
          'complexity_level' => '—Å—Ä–µ–¥–Ω–∏–π',
          'character_consistency' => true
        },
        'themes' => {
          'primary' => '—Ä–∞–±–æ—á–∞—è –∫–æ–º–µ–¥–∏—è',
          'secondary' => [
            '–æ—à–∏–±–æ—á–Ω–∞—è –∏–¥–µ–Ω—Ç–∏—á–Ω–æ—Å—Ç—å',
            '–±—é—Ä–æ–∫—Ä–∞—Ç–∏—á–µ—Å–∫–∏–π –∞–±—Å—É—Ä–¥',
            '–æ–±—ã—á–Ω—ã–µ —Å–∏—Ç—É–∞—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –∏–¥—É—Ç –Ω–µ —Ç–∞–∫'
          ]
        },
        'status' => {
          'last_generated' => nil,
          'generation_count' => 0,
          'characters_created' => 0,
          'active_storylines' => [],
          'chapters_written' => 0
        }
      }
    }

    File.write('_data/book_metadata.yml', initial_data.to_yaml)
    puts '  üìù Reset: book_metadata.yml'
  end

  def reset_characters_yml
    initial_data = {
      'en' => {
        'characters' => {}
      }
    }

    File.write('_data/characters.yml', initial_data.to_yaml)
    puts '  üìù Reset: characters.yml'
  end

  def reset_generation_log_yml
    initial_data = {
      'generations' => [],
      'used_plot_devices' => [],
      'character_interactions' => {}
    }

    File.write('_data/generation_log.yml', initial_data.to_yaml)
    puts '  üìù Reset: generation_log.yml'
  end
end

# Command line interface
if __FILE__ == $PROGRAM_NAME
  reset_tool = BookReset.new

  case ARGV[0]
  when 'all'
    force = ARGV.include?('--force')
    reset_tool.reset_all(force: force)

  when 'characters'
    force = ARGV.include?('--force')
    reset_tool.reset_characters(force: force)

  when 'chapters'
    force = ARGV.include?('--force')
    reset_tool.reset_chapters(force: force)

  when 'data'
    reset_tool.reset_data_files

  when 'site'
    reset_tool.reset_generated_site

  when 'status'
    reset_tool.status

  else
    puts 'One Review Man - Book Reset Tool'
    puts ''
    puts 'Usage:'
    puts '  ruby reset_book.rb all              # Reset everything (interactive)'
    puts '  ruby reset_book.rb all --force      # Reset everything (no prompts)'
    puts '  ruby reset_book.rb characters       # Reset only characters'
    puts '  ruby reset_book.rb chapters         # Reset only chapters'
    puts '  ruby reset_book.rb data             # Reset only _data/*.yml files'
    puts '  ruby reset_book.rb site             # Clean generated site files'
    puts '  ruby reset_book.rb status           # Show current book status'
    puts ''
    puts 'Examples:'
    puts '  ruby reset_book.rb status           # Check what content exists'
    puts '  ruby reset_book.rb characters       # Remove all characters'
    puts '  ruby reset_book.rb all              # Full reset (with confirmation)'
    puts '  ruby reset_book.rb all --force      # Full reset (no confirmation)'
    puts ''
    puts '‚ö†Ô∏è  WARNING: Reset operations delete content permanently!'
  end
end
</file>

<file path="scripts/test_task_models.rb">
#!/usr/bin/env ruby
# frozen_string_literal: true

require_relative 'llm_service'

# Test script to verify task-specific model configuration
class TaskModelTester
  def initialize
    @llm_service = LLMService.new
  end

  def test_task_models
    puts 'üß™ Testing task-specific model configuration...'
    puts '=' * 50

    # Test model selection for different tasks
    test_model_selection

    # Test task options
    test_task_options

    # Test naming conventions in prompts
    test_naming_conventions

    puts "\n‚úÖ Task-specific model tests completed!"
  end

  private

  def test_model_selection
    puts "\nüìã Testing model selection for different tasks:"

    # Access private methods for testing
    generation_model = @llm_service.send(:get_model_for_task, 'generation')
    translation_model = @llm_service.send(:get_model_for_task, 'translation')
    chat_model = @llm_service.send(:get_model_for_task, 'chat')
    unknown_model = @llm_service.send(:get_model_for_task, 'unknown_task')

    puts "  Generation tasks: #{generation_model}"
    puts "  Translation tasks: #{translation_model}"
    puts "  Chat tasks: #{chat_model}"
    puts "  Unknown task (fallback): #{unknown_model}"
  end

  def test_task_options
    puts "\n‚öôÔ∏è  Testing task-specific options:"

    # Test different task options
    generation_options = @llm_service.send(:get_task_options, 'generation', {})
    translation_options = @llm_service.send(:get_task_options, 'translation', {})
    chat_options = @llm_service.send(:get_task_options, 'chat', {})

    puts '  Generation options:'
    puts "    Temperature: #{generation_options[:temperature]}"
    puts "    Max tokens: #{generation_options[:max_tokens]}"

    puts '  Translation options:'
    puts "    Temperature: #{translation_options[:temperature]}"
    puts "    Max tokens: #{translation_options[:max_tokens]}"

    puts '  Chat options:'
    puts "    Temperature: #{chat_options[:temperature]}"
    puts "    Max tokens: #{chat_options[:max_tokens]}"
  end

  def test_naming_conventions
    puts "\nüè∑Ô∏è  Testing naming conventions in character schema:"

    # Test character prompt with schema
    test_prompt = 'Create a test character for verification'
    enhanced_prompt = @llm_service.send(:build_character_prompt_with_schema, test_prompt)

    # Check if the schema includes the naming conventions
    if enhanced_prompt.include?('real_name')
      puts '  ‚úÖ Character schema includes real_name field'
    else
      puts '  ‚ùå Character schema missing real_name field'
    end

    if enhanced_prompt.include?('Satoru') && enhanced_prompt.include?('Genki')
      puts '  ‚úÖ Schema includes protagonist naming examples'
    else
      puts '  ‚ùå Schema missing protagonist naming examples'
    end

    if enhanced_prompt.include?('NAMING CONVENTIONS')
      puts '  ‚úÖ Schema includes naming convention guidance'
    else
      puts '  ‚ùå Schema missing naming convention guidance'
    end

    # Test Russian transliteration in translation prompts
    puts "\nüá∑üá∫ Testing Russian transliteration in translation prompts:"

    # Test chapter translation prompt
    chapter_prompt = @llm_service.send(:build_chapter_translation_prompt,
                                       'Test Chapter', 'Test Summary', 'Test Content', 'ru')

    if chapter_prompt.include?('–í–∞–Ω—Ä–µ–≤—å—é–º–µ–Ω')
      puts "  ‚úÖ Chapter translation includes Russian transliteration '–í–∞–Ω—Ä–µ–≤—å—é–º–µ–Ω'"
    else
      puts '  ‚ùå Chapter translation missing Russian transliteration'
    end

    if chapter_prompt.include?('–°–∞—Ç–æ—Ä—É') && chapter_prompt.include?('–ì–µ–Ω–∫–∏')
      puts '  ‚úÖ Chapter translation includes Russian name transliterations'
    else
      puts '  ‚ùå Chapter translation missing Russian name transliterations'
    end

    # Test character translation prompt
    character_prompt = @llm_service.send(:build_character_translation_prompt,
                                         'One Review Man', 'Test description', ['trait1'],
                                         'Test skills', 'Test phrase', 'Test backstory',
                                         'Test quirks', 'ru')

    if character_prompt.include?('–í–∞–Ω—Ä–µ–≤—å—é–º–µ–Ω')
      puts "  ‚úÖ Character translation includes Russian transliteration '–í–∞–Ω—Ä–µ–≤—å—é–º–µ–Ω'"
    else
      puts '  ‚ùå Character translation missing Russian transliteration'
    end

    if character_prompt.include?('–ò–ò-–£—Å–∏–ª–µ–Ω–Ω—ã–π –£—á–µ–Ω–∏–∫')
      puts '  ‚úÖ Character translation includes AI-Enhanced Disciple Russian translation'
    else
      puts '  ‚ùå Character translation missing AI-Enhanced Disciple Russian translation'
    end
  end
end

# Run the test if this script is executed directly
if __FILE__ == $PROGRAM_NAME
  tester = TaskModelTester.new
  tester.test_task_models
end
</file>

<file path=".rubocop.yml">
inherit_from: .rubocop_todo.yml

AllCops:
  TargetRubyVersion: 3.3
  NewCops: enable
  Exclude:
    - '_site/**/*'
    - '.jekyll-cache/**/*'
    - 'vendor/**/*'
    - 'Gemfile.lock'

Layout/LineLength:
  Exclude:
    - 'scripts/prompts/**/*'
  AllowedPatterns:
    - '\s*#.*'
    - '^\s*PROMPT.*'
</file>

<file path=".ruby-version">
3.3.5
</file>

<file path="characters.md">
---
layout: default
title: "Characters - One Review Man"
lang: en
permalink: /characters/
nav_order: 2
---

# Characters

Meet the quirky cast of **One Review Man** - each with their own unique personality, backstory, and role in our workplace comedy!

{% assign characters = site.characters | where: "lang", page.lang %}

{% if characters and characters.size > 0 %}
  <div class="characters-grid">
    {% for character in characters %}
      <div class="character-profile-card">
        <div class="character-header">
          <h2 class="character-name">
            {% assign character_page = site.characters | where: "slug", character.slug | first %}
            {% if character_page %}
              <a href="{{ character_page.url }}">{{ character.name }}</a>
            {% else %}
              <a href="/characters/{{ character.slug | slugify }}">{{ character.name }}</a>
            {% endif %}
          </h2>
          {% if character.first_appearance %}
            <span class="first-appearance-badge">
              Since {{ character.first_appearance }}
            </span>
          {% endif %}
        </div>
        
        <p class="character-description">{{ character.description }}</p>
        
        {% if character.personality_traits and character.personality_traits.size > 0 %}
          <div class="traits-section">
            <strong>Personality:</strong>
            <div class="traits-list">
              {% for trait in character.personality_traits %}
                <span class="trait-badge">{{ trait }}</span>
              {% endfor %}
            </div>
          </div>
        {% endif %}
        
        {% if character.catchphrase %}
          <div class="catchphrase">
            <em>"{{ character.catchphrase }}"</em>
          </div>
        {% endif %}
        
        {% if character.relationships and character.relationships.size > 0 %}
          <div class="relationships-section">
            <strong>Relationships:</strong>
            <ul class="relationships-list">
              {% for relationship in character.relationships %}
                {% assign other_char = site.data.characters.characters[relationship.character] %}
                {% assign other_char_page = site.characters | where: "slug", relationship.character | first %}
                <li>
                  {% if other_char %}
                    {% if other_char_page %}
                      <a href="{{ other_char_page.url }}">{{ other_char.name }}</a>
                    {% else %}
                      <a href="/characters/{{ relationship.character | slugify }}">{{ other_char.name }}</a>
                    {% endif %}
                  {% else %}
                    {{ relationship.character }}
                  {% endif %}
                  - {{ relationship.type }}
                </li>
              {% endfor %}
            </ul>
          </div>
        {% endif %}
        
        {% comment %} Count appearances {% endcomment %}
        {% assign appearances = site.chapters | where_exp: "chapter", "chapter.characters contains character.slug" %}
        {% if appearances.size > 0 %}
          <div class="appearances-count">
            <strong>Appears in {{ appearances.size }} chapter{% if appearances.size != 1 %}s{% endif %}</strong>
          </div>
        {% endif %}
      </div>
    {% endfor %}
  </div>
{% else %}
  <div class="no-characters">
    <h2>No Characters Yet!</h2>
    <p>Our cast of characters is waiting to be created. Each chapter may introduce new personalities to join the comedy!</p>
    <div class="character-teaser">
      <h3>Coming Soon:</h3>
      <ul>
        <li>ü§î The perpetually confused protagonist</li>
        <li>üòè The sarcastic office veteran</li>
        <li>üìã The overly enthusiastic manager</li>
        <li>ü§ñ The tech support guru</li>
        <li>‚òï The coffee-obsessed intern</li>
      </ul>
    </div>
    <a href="/" class="back-home">‚Üê Back to Home</a>
  </div>
{% endif %}

---

## Character Statistics

<div class="character-stats">
  <div class="stats-grid">
    <div class="stat-box">
      <span class="stat-number">{{ characters.size | default: 0 }}</span>
      <span class="stat-label">Total Characters</span>
    </div>
    
    {% assign total_chapters = site.chapters.size %}
    {% if total_chapters > 0 %}
      <div class="stat-box">
        <span class="stat-number">{{ characters.size | times: 100 | divided_by: total_chapters }}%</span>
        <span class="stat-label">Characters per Chapter</span>
      </div>
    {% endif %}
    
    {% assign characters_with_relationships = characters | where_exp: "char", "char.relationships.size > 0" %}
    <div class="stat-box">
      <span class="stat-number">{{ characters_with_relationships.size | default: 0 }}</span>
      <span class="stat-label">Have Relationships</span>
    </div>
  </div>
</div>

<style>
.characters-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
  gap: 2rem;
  margin: 2rem 0;
}

.character-profile-card {
  background: white;
  border: 1px solid #e1e5e9;
  border-radius: 12px;
  padding: 2rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.character-profile-card:hover {
  transform: translateY(-3px);
  box-shadow: 0 6px 12px rgba(0,0,0,0.15);
}

.character-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 1rem;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.character-name {
  margin: 0;
  color: #2c3e50;
  flex: 1;
}

.character-name a {
  color: inherit;
  text-decoration: none;
}

.character-name a:hover {
  color: #3498db;
}

.first-appearance-badge {
  background-color: #e8f4f8;
  color: #3498db;
  padding: 0.3rem 0.8rem;
  border-radius: 12px;
  font-size: 0.8rem;
  font-weight: bold;
  white-space: nowrap;
}

.character-description {
  color: #5a6c7d;
  line-height: 1.5;
  margin-bottom: 1.5rem;
  font-style: italic;
}

.traits-section, .relationships-section {
  margin-bottom: 1rem;
}

.traits-list {
  display: flex;
  flex-wrap: wrap;
  gap: 0.4rem;
  margin-top: 0.5rem;
}

.trait-badge {
  background-color: #3498db;
  color: white;
  padding: 0.3rem 0.7rem;
  border-radius: 15px;
  font-size: 0.8rem;
  font-weight: 500;
}

.catchphrase {
  background-color: #f8f9fa;
  padding: 1rem;
  border-left: 4px solid #e74c3c;
  border-radius: 0 6px 6px 0;
  margin: 1rem 0;
  color: #2c3e50;
  font-size: 1.1rem;
}

.relationships-list {
  list-style: none;
  padding: 0;
  margin-top: 0.5rem;
}

.relationships-list li {
  padding: 0.3rem 0;
  color: #7f8c8d;
}

.relationships-list a {
  color: #3498db;
  text-decoration: none;
  font-weight: 500;
}

.relationships-list a:hover {
  text-decoration: underline;
}

.appearances-count {
  margin-top: 1.5rem;
  padding: 0.8rem;
  background-color: #e8f5e8;
  border-radius: 6px;
  text-align: center;
  color: #27ae60;
  font-size: 0.9rem;
}

.no-characters {
  text-align: center;
  padding: 4rem 2rem;
  background-color: #f8f9fa;
  border-radius: 12px;
  margin: 2rem 0;
}

.no-characters h2 {
  color: #2c3e50;
  margin-bottom: 1rem;
}

.no-characters p {
  color: #7f8c8d;
  font-size: 1.1rem;
  margin-bottom: 2rem;
}

.character-teaser {
  background-color: white;
  padding: 2rem;
  border-radius: 8px;
  margin: 2rem 0;
  border: 2px dashed #e1e5e9;
}

.character-teaser h3 {
  color: #3498db;
  margin-bottom: 1rem;
}

.character-teaser ul {
  text-align: left;
  display: inline-block;
  color: #7f8c8d;
}

.character-teaser li {
  margin-bottom: 0.5rem;
}

.back-home {
  background-color: #3498db;
  color: white;
  padding: 0.8rem 1.5rem;
  border-radius: 6px;
  text-decoration: none;
  font-weight: bold;
  transition: background-color 0.2s ease;
}

.back-home:hover {
  background-color: #2980b9;
  color: white;
  text-decoration: none;
}

.character-stats {
  background-color: #f8f9fa;
  padding: 2rem;
  border-radius: 12px;
  margin-top: 3rem;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 2rem;
  text-align: center;
}

.stat-box {
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 1rem;
  background-color: white;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.05);
}

.stat-number {
  font-size: 2.5rem;
  font-weight: bold;
  color: #3498db;
  line-height: 1;
}

.stat-label {
  color: #7f8c8d;
  font-size: 0.9rem;
  margin-top: 0.5rem;
}

@media (max-width: 768px) {
  .characters-grid {
    grid-template-columns: 1fr;
  }
  
  .character-header {
    flex-direction: column;
    align-items: flex-start;
  }
  
  .stats-grid {
    grid-template-columns: 1fr;
    gap: 1rem;
  }
}
</style>
</file>

<file path="characters.ru.md">
---
layout: default
title: "–ü–µ—Ä—Å–æ–Ω–∞–∂–∏ - One Review Man"
lang: ru
permalink: /characters/
nav_order: 2
---

# –ü–µ—Ä—Å–æ–Ω–∞–∂–∏

–ü–æ–∑–Ω–∞–∫–æ–º—å—Ç–µ—Å—å —Å —ç–∫—Å—Ü–µ–Ω—Ç—Ä–∏—á–Ω–æ–π –∫–æ–º–∞–Ω–¥–æ–π **One Review Man** - –∫–∞–∂–¥—ã–π —Å–æ —Å–≤–æ–µ–π —É–Ω–∏–∫–∞–ª—å–Ω–æ–π –ª–∏—á–Ω–æ—Å—Ç—å—é, –ø—Ä–µ–¥—ã—Å—Ç–æ—Ä–∏–µ–π –∏ —Ä–æ–ª—å—é –≤ –Ω–∞—à–µ–π —Ä–∞–±–æ—á–µ–π –∫–æ–º–µ–¥–∏–∏!

{% assign characters = site.characters | where: "lang", page.lang %}

{% if characters and characters.size > 0 %}
  <div class="characters-grid">
    {% for character in characters %}
      <div class="character-profile-card">
        <div class="character-header">
          <h2 class="character-name">
            {% assign character_page = site.characters | where: "slug", character.slug | first %}
            {% if character_page %}
              <a href="{{ character_page.url }}">{{ character.name }}</a>
            {% else %}
              <a href="/characters/{{ character.slug | slugify }}">{{ character.name }}</a>
            {% endif %}
          </h2>
          {% if character.first_appearance %}
            <span class="first-appearance-badge">
              –° {{ character.first_appearance }}
            </span>
          {% endif %}
        </div>
        
        <p class="character-description">{{ character.description }}</p>
        
        {% if character.personality_traits and character.personality_traits.size > 0 %}
          <div class="traits-section">
            <strong>–•–∞—Ä–∞–∫—Ç–µ—Ä:</strong>
            <div class="traits-list">
              {% for trait in character.personality_traits %}
                <span class="trait-badge">{{ trait }}</span>
              {% endfor %}
            </div>
          </div>
        {% endif %}
        
        {% if character.catchphrase %}
          <div class="catchphrase">
            <em>"{{ character.catchphrase }}"</em>
          </div>
        {% endif %}
        
        {% if character.relationships and character.relationships.size > 0 %}
          <div class="relationships-section">
            <strong>–°–≤—è–∑–∏:</strong>
            <ul class="relationships-list">
              {% for relationship in character.relationships %}
                {% assign other_char = site.data.characters.ru.characters[relationship.character] %}
                {% assign other_char_page = site.characters | where: "slug", relationship.character | first %}
                <li>
                  {% if other_char %}
                    {% if other_char_page %}
                      <a href="{{ other_char_page.url }}">{{ other_char.name }}</a>
                    {% else %}
                      <a href="/characters/{{ relationship.character | slugify }}">{{ other_char.name }}</a>
                    {% endif %}
                  {% else %}
                    {{ relationship.character }}
                  {% endif %}
                  - {{ relationship.type }}
                </li>
              {% endfor %}
            </ul>
          </div>
        {% endif %}
        
        {% comment %} Count appearances {% endcomment %}
        {% assign appearances = site.chapters | where: "lang", "ru" | where_exp: "chapter", "chapter.characters contains character.slug" %}
        {% if appearances.size > 0 %}
          <div class="appearances-count">
            <strong>–ü–æ—è–≤–ª—è–µ—Ç—Å—è –≤ {{ appearances.size }} –≥–ª–∞–≤{% if appearances.size == 1 %}–µ{% elsif appearances.size < 5 %}–∞—Ö{% else %}–∞—Ö{% endif %}</strong>
          </div>
        {% endif %}
      </div>
    {% endfor %}
  </div>
{% else %}
  <div class="no-characters">
    <h2>–ü–æ–∫–∞ –ù–µ—Ç –ü–µ—Ä—Å–æ–Ω–∞–∂–µ–π!</h2>
    <p>–ù–∞—à–∞ –∫–æ–º–∞–Ω–¥–∞ –ø–µ—Ä—Å–æ–Ω–∞–∂–µ–π –∂–¥–µ—Ç —Å–æ–∑–¥–∞–Ω–∏—è. –ö–∞–∂–¥–∞—è –≥–ª–∞–≤–∞ –º–æ–∂–µ—Ç –ø—Ä–µ–¥—Å—Ç–∞–≤–∏—Ç—å –Ω–æ–≤—ã–µ –ª–∏—á–Ω–æ—Å—Ç–∏ –¥–ª—è —É—á–∞—Å—Ç–∏—è –≤ –∫–æ–º–µ–¥–∏–∏!</p>
    <div class="character-teaser">
      <h3>–°–∫–æ—Ä–æ:</h3>
      <ul>
        <li>ü§î –í–µ—á–Ω–æ –æ–∑–∞–¥–∞—á–µ–Ω–Ω—ã–π –ø—Ä–æ—Ç–∞–≥–æ–Ω–∏—Å—Ç</li>
        <li>üòè –°–∞—Ä–∫–∞—Å—Ç–∏—á–Ω—ã–π –æ—Ñ–∏—Å–Ω—ã–π –≤–µ—Ç–µ—Ä–∞–Ω</li>
        <li>üìã –ß—Ä–µ–∑–º–µ—Ä–Ω–æ —ç–Ω—Ç—É–∑–∏–∞—Å—Ç–∏—á–Ω—ã–π –º–µ–Ω–µ–¥–∂–µ—Ä</li>
        <li>ü§ñ –ì—É—Ä—É —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–æ–π –ø–æ–¥–¥–µ—Ä–∂–∫–∏</li>
        <li>‚òï –û–¥–µ—Ä–∂–∏–º—ã–π –∫–æ—Ñ–µ —Å—Ç–∞–∂–µ—Ä</li>
      </ul>
    </div>
    <a href="/" class="back-home">‚Üê –ù–∞–∑–∞–¥ –Ω–∞ –≥–ª–∞–≤–Ω—É—é</a>
  </div>
{% endif %}

---

## –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –ü–µ—Ä—Å–æ–Ω–∞–∂–µ–π

<div class="character-stats">
  <div class="stats-grid">
    <div class="stat-box">
      <span class="stat-number">{{ characters.size | default: 0 }}</span>
      <span class="stat-label">–í—Å–µ–≥–æ –ü–µ—Ä—Å–æ–Ω–∞–∂–µ–π</span>
    </div>
    
    {% assign total_chapters = site.chapters | where: "lang", "ru" | size %}
    {% if total_chapters > 0 %}
      <div class="stat-box">
        <span class="stat-number">{{ characters.size | times: 100 | divided_by: total_chapters }}%</span>
        <span class="stat-label">–ü–µ—Ä—Å–æ–Ω–∞–∂–µ–π –Ω–∞ –ì–ª–∞–≤—É</span>
      </div>
    {% endif %}
    
    {% assign characters_with_relationships = characters | where_exp: "char", "char.relationships.size > 0" %}
    <div class="stat-box">
      <span class="stat-number">{{ characters_with_relationships.size | default: 0 }}</span>
      <span class="stat-label">–ï—Å—Ç—å –û—Ç–Ω–æ—à–µ–Ω–∏—è</span>
    </div>
  </div>
</div>

<style>
.characters-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
  gap: 2rem;
  margin: 2rem 0;
}

.character-profile-card {
  background: white;
  border: 1px solid #e1e5e9;
  border-radius: 12px;
  padding: 2rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.character-profile-card:hover {
  transform: translateY(-3px);
  box-shadow: 0 6px 12px rgba(0,0,0,0.15);
}

.character-header {
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  margin-bottom: 1rem;
  flex-wrap: wrap;
  gap: 0.5rem;
}

.character-name {
  margin: 0;
  color: #2c3e50;
  flex: 1;
}

.character-name a {
  color: inherit;
  text-decoration: none;
}

.character-name a:hover {
  color: #3498db;
}

.first-appearance-badge {
  background-color: #e8f4f8;
  color: #3498db;
  padding: 0.3rem 0.8rem;
  border-radius: 12px;
  font-size: 0.8rem;
  font-weight: bold;
  white-space: nowrap;
}

.character-description {
  color: #5a6c7d;
  line-height: 1.5;
  margin-bottom: 1.5rem;
  font-style: italic;
}

.traits-section, .relationships-section {
  margin-bottom: 1rem;
}

.traits-list {
  display: flex;
  flex-wrap: wrap;
  gap: 0.4rem;
  margin-top: 0.5rem;
}

.trait-badge {
  background-color: #3498db;
  color: white;
  padding: 0.3rem 0.7rem;
  border-radius: 15px;
  font-size: 0.8rem;
  font-weight: bold;
}

.catchphrase {
  background-color: #f8f9fa;
  border-left: 4px solid #3498db;
  padding: 1rem;
  margin: 1rem 0;
  border-radius: 4px;
  color: #2c3e50;
}

.relationships-section {
  background-color: #f1f8ff;
  padding: 1rem;
  border-radius: 6px;
  border: 1px solid #dbeafe;
}

.relationships-list {
  margin: 0.5rem 0 0 0;
  padding-left: 1.2rem;
}

.relationships-list li {
  margin-bottom: 0.3rem;
}

.relationships-list a {
  color: #3498db;
  text-decoration: none;
  font-weight: bold;
}

.relationships-list a:hover {
  text-decoration: underline;
}

.appearances-count {
  background-color: #e8f5e8;
  color: #27ae60;
  padding: 0.5rem;
  border-radius: 6px;
  font-size: 0.9rem;
  text-align: center;
  border: 1px solid #d5f4e6;
  margin-top: 1rem;
}

.no-characters {
  text-align: center;
  padding: 4rem 2rem;
  background-color: #f8f9fa;
  border-radius: 12px;
  margin: 2rem 0;
}

.no-characters h2 {
  color: #2c3e50;
  margin-bottom: 1rem;
}

.no-characters p {
  color: #7f8c8d;
  font-size: 1.1rem;
  margin-bottom: 2rem;
}

.character-teaser {
  background-color: white;
  padding: 2rem;
  border-radius: 8px;
  margin: 2rem 0;
  border: 1px solid #e1e5e9;
}

.character-teaser h3 {
  color: #3498db;
  margin-bottom: 1rem;
}

.character-teaser ul {
  text-align: left;
  display: inline-block;
  color: #5a6c7d;
}

.back-home {
  background-color: #3498db;
  color: white;
  padding: 0.8rem 1.5rem;
  border-radius: 6px;
  text-decoration: none;
  display: inline-block;
  transition: background-color 0.2s ease;
}

.back-home:hover {
  background-color: #2980b9;
  color: white;
  text-decoration: none;
}

.character-stats {
  background-color: #f8f9fa;
  border-radius: 12px;
  padding: 2rem;
  margin: 3rem 0;
}

.stats-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 2rem;
  text-align: center;
}

.stat-box {
  background-color: white;
  padding: 1.5rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.stat-number {
  display: block;
  font-size: 2.5rem;
  font-weight: bold;
  color: #3498db;
  line-height: 1;
}

.stat-label {
  color: #7f8c8d;
  font-size: 0.9rem;
  margin-top: 0.5rem;
  display: block;
}

@media (max-width: 768px) {
  .characters-grid {
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  
  .character-profile-card {
    padding: 1rem;
  }
  
  .character-header {
    flex-direction: column;
    align-items: flex-start;
  }
  
  .stats-grid {
    grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
    gap: 1rem;
  }
  
  .stat-number {
    font-size: 2rem;
  }
}
</style>
</file>

<file path="index.ru.md">
---
layout: default
title: "–í—Å–µ –ì–ª–∞–≤—ã - One Review Man"
lang: ru
permalink: /
nav_order: 1
---

# –í—Å–µ –ì–ª–∞–≤—ã

{% assign chapters = site.chapters | where: "lang", page.lang | sort: "chapter_number" %}

{% if chapters.size > 0 %}
  <div class="chapters-grid">
    {% for chapter in chapters %}
      <div class="chapter-card">
        <div class="chapter-header">
          <span class="chapter-number">–ì–ª–∞–≤–∞ {{ chapter.chapter_number }}</span>
          {% if chapter.generated_date %}
            <span class="chapter-date">{{ chapter.generated_date | date: "%d.%m.%Y" }}</span>
          {% endif %}
        </div>
        
        <h2 class="chapter-title">
          <a href="{{ chapter.url }}">{{ chapter.title }}</a>
        </h2>
        
        {% if chapter.summary %}
          <p class="chapter-summary">{{ chapter.summary }}</p>
        {% endif %}
        
        <!-- {% if chapter.characters and chapter.characters.size > 0 %}
          <div class="chapter-characters">
            <strong>–ü–µ—Ä—Å–æ–Ω–∞–∂–∏:</strong>
            {% for character_slug in chapter.characters %}
              {% assign character = site.data.characters.ru.characters[character_slug] %}
              {% if character %}
                <span class="character-tag">{{ character.name }}</span>
              {% endif %}
            {% endfor %}
          </div>
        {% endif %}
        
        {% if chapter.new_characters and chapter.new_characters.size > 0 %}
          <div class="new-characters-badge">
            ‚ú® –ó–Ω–∞–∫–æ–º–∏—Ç —Å {{ chapter.new_characters.size }} –Ω–æ–≤—ã–º{% if chapter.new_characters.size > 1 %}–∏{% endif %} –ø–µ—Ä—Å–æ–Ω–∞–∂{% if chapter.new_characters.size > 1 %}–∞–º–∏{% else %}–µ–º{% endif %}
          </div>
        {% endif %} -->
      </div>
    {% endfor %}
  </div>
{% else %}
  <div class="no-chapters">
    <h2>–ü–æ–∫–∞ –ù–µ—Ç –ì–ª–∞–≤!</h2>
    <p>–ò—Å—Ç–æ—Ä–∏—è –≤–æ—Ç-–≤–æ—Ç –Ω–∞—á–Ω–µ—Ç—Å—è. –ó–∞–≥–ª—è–Ω–∏—Ç–µ –ø–æ–∑–∂–µ, —á—Ç–æ–±—ã –ø—Ä–æ—á–∏—Ç–∞—Ç—å –ø–µ—Ä–≤—É—é –≥–ª–∞–≤—É –≤–µ—Å–µ–ª–æ–π —Ä–∞–±–æ—á–µ–π –∫–æ–º–µ–¥–∏–∏!</p>
    <a href="/" class="back-home">‚Üê –ù–∞–∑–∞–¥ –Ω–∞ –≥–ª–∞–≤–Ω—É—é</a>
  </div>
{% endif %}

<style>
.chapters-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
  gap: 2rem;
  margin: 2rem 0;
}

.chapter-card {
  background: white;
  border: 1px solid #e1e5e9;
  border-radius: 12px;
  padding: 1.5rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.chapter-card:hover {
  transform: translateY(-3px);
  box-shadow: 0 6px 12px rgba(0,0,0,0.15);
}

.chapter-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
}

.chapter-number {
  background-color: #3498db;
  color: white;
  padding: 0.3rem 0.8rem;
  border-radius: 15px;
  font-size: 0.9rem;
  font-weight: bold;
}

.chapter-date {
  color: #7f8c8d;
  font-size: 0.9rem;
}

.chapter-title {
  margin: 0 0 1rem 0;
  color: #2c3e50;
}

.chapter-title a {
  color: inherit;
  text-decoration: none;
}

.chapter-title a:hover {
  color: #3498db;
}

.chapter-summary {
  color: #5a6c7d;
  font-style: italic;
  line-height: 1.5;
  margin-bottom: 1rem;
}

.chapter-characters {
  margin-bottom: 1rem;
  font-size: 0.9rem;
}

.character-tag {
  background-color: #ecf0f1;
  color: #2c3e50;
  padding: 0.2rem 0.5rem;
  border-radius: 10px;
  font-size: 0.8rem;
  margin-right: 0.5rem;
  display: inline-block;
  margin-bottom: 0.3rem;
}

.new-characters-badge {
  background-color: #e8f5e8;
  color: #27ae60;
  padding: 0.5rem;
  border-radius: 6px;
  font-size: 0.9rem;
  text-align: center;
  border: 1px solid #d5f4e6;
}

.no-chapters {
  text-align: center;
  padding: 4rem 2rem;
  background-color: #f8f9fa;
  border-radius: 12px;
  margin: 2rem 0;
}

.no-chapters h2 {
  color: #2c3e50;
  margin-bottom: 1rem;
}

.no-chapters p {
  color: #7f8c8d;
  font-size: 1.1rem;
  margin-bottom: 2rem;
}

.back-home {
  background-color: #3498db;
  color: white;
  padding: 0.8rem 1.5rem;
  border-radius: 6px;
  text-decoration: none;
  display: inline-block;
  transition: background-color 0.2s ease;
}

.back-home:hover {
  background-color: #2980b9;
  color: white;
  text-decoration: none;
}

.progress-section {
  background-color: #f8f9fa;
  border-radius: 12px;
  padding: 2rem;
  margin: 3rem 0;
}

.progress-stats {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
  gap: 2rem;
  margin-bottom: 2rem;
  text-align: center;
}

.stat {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.stat-number {
  font-size: 2.5rem;
  font-weight: bold;
  color: #3498db;
  line-height: 1;
}

.stat-label {
  color: #7f8c8d;
  font-size: 0.9rem;
  margin-top: 0.5rem;
}

.progress-bar {
  background-color: #ecf0f1;
  border-radius: 20px;
  height: 20px;
  overflow: hidden;
}

.progress-fill {
  background: linear-gradient(90deg, #3498db 0%, #2ecc71 100%);
  height: 100%;
  border-radius: 20px;
  transition: width 0.3s ease;
}

@media (max-width: 768px) {
  .chapters-grid {
    grid-template-columns: 1fr;
    gap: 1rem;
  }
  
  .chapter-card {
    padding: 1rem;
  }
  
  .progress-stats {
    grid-template-columns: repeat(3, 1fr);
    gap: 1rem;
  }
  
  .stat-number {
    font-size: 2rem;
  }
}
</style>
</file>

<file path="_layouts/default.html">
<!DOCTYPE html>
<html lang="{{ page.lang | default: site.lang | default: "en" }}">

  {%- include head.html -%}

  <body>
    {%- include header.html -%}

    <main class="page-content" aria-label="Content">
      <div class="wrapper">
        {{ content }}
      </div>
    </main>
  </body>
</html>
</file>

<file path="scripts/prompts/chapter_prompts.txt">
# Chapter Generation Prompts for "One Review Man"
# Programming comedy parody of "One-Punch Man"

## Base Chapter Prompt
You are writing "One Review Man" - a programming comedy parody of the manga/anime "One-Punch Man".

Generate Chapter {CHAPTER_NUMBER}

CORE CONCEPT:
- One Review Man (real name: {ONE_REVIEW_MAN_REAL_NAME}) is a super-programmer who writes perfect code
- All his pull requests are accepted and merged without comments on the first review
- Like Saitama in One-Punch Man, he's become bored with his overwhelming ability
- Almost nobody takes him seriously or believes in his abilities (just like in One-Punch Man)
- Colleagues often dismiss his achievements as luck, timing, or trivial problems
- His unimpressive appearance and casual demeanor make people underestimate him
- The story parodies programming culture, code reviews, and tech workplace dynamics

NAMING CONVENTIONS (CRITICAL):
- One Review Man's real name is "{ONE_REVIEW_MAN_REAL_NAME}" (to be generated during character creation)
- AI-Enhanced Disciple's real name is "{AI_ENHANCED_DISCIPLE_REAL_NAME}" (to be generated during character creation)
- Most characters call them by professional titles: "One Review Man", "AI-Enhanced Disciple"
- ONLY when {ONE_REVIEW_MAN_REAL_NAME} and {AI_ENHANCED_DISCIPLE_REAL_NAME} speak to each other do they use real names
- {AI_ENHANCED_DISCIPLE_REAL_NAME} is the ONLY character who calls him "{ONE_REVIEW_MAN_REAL_NAME}" (usually "{ONE_REVIEW_MAN_REAL_NAME}-sensei")
- Everyone else must use "One Review Man" or respectful titles
- This creates the same dynamic as Saitama/Genos in the original

TRANSLATION NOTES:
- For Russian: "One Review Man" becomes "–í–∞–Ω—Ä–µ–≤—å—é–º–µ–Ω" (like "One Punch Man" ‚Üí "–í–∞–Ω–ø–∞–Ω—á–º–µ–Ω")
- Real names keep Japanese style when generated
- Respectful address: "{ONE_REVIEW_MAN_REAL_NAME}-—Å–µ–Ω—Å–µ–π" for "{ONE_REVIEW_MAN_REAL_NAME}-sensei"

Context:
- Setting: Modern tech company/startup environment
- Style: Absurdist programming humor with One-Punch Man references
- Length: {TARGET_LENGTH} words
- Previous chapters: {PREVIOUS_CHAPTERS_SUMMARY}

{CHARACTER_CONTEXT}

KEY CHARACTERS TO REFERENCE:
- One Review Man ({ONE_REVIEW_MAN_REAL_NAME}): The protagonist, master programmer (parody of Saitama)
  * Most people call him "One Review Man" or "One Review Man-san"
  * Only {AI_ENHANCED_DISCIPLE_REAL_NAME} calls him "{ONE_REVIEW_MAN_REAL_NAME}" or "{ONE_REVIEW_MAN_REAL_NAME}-sensei"
  * Despite his incredible abilities, colleagues rarely take him seriously
  * Often dismissed as "just lucky" or "only good at simple problems"
- The AI-Enhanced Disciple ({AI_ENHANCED_DISCIPLE_REAL_NAME}): Cyborg-like character with neurointerface who seeks to learn (parody of Genos)
  * {ONE_REVIEW_MAN_REAL_NAME} calls him "{AI_ENHANCED_DISCIPLE_REAL_NAME}" when they're talking privately
  * Others call him "AI-Enhanced Disciple" or "Disciple-kun"
  * One of the few who truly recognizes {ONE_REVIEW_MAN_REAL_NAME}'s abilities

DIALOGUE RULES:
- Other characters ‚Üí One Review Man: "One Review Man", "One Review Man-san", "sir", etc.
- {AI_ENHANCED_DISCIPLE_REAL_NAME} ‚Üí {ONE_REVIEW_MAN_REAL_NAME}: "{ONE_REVIEW_MAN_REAL_NAME}-sensei", "{ONE_REVIEW_MAN_REAL_NAME}", "Master"
- {ONE_REVIEW_MAN_REAL_NAME} ‚Üí {AI_ENHANCED_DISCIPLE_REAL_NAME}: "{AI_ENHANCED_DISCIPLE_REAL_NAME}", occasionally "Disciple"
- Others ‚Üí {AI_ENHANCED_DISCIPLE_REAL_NAME}: "AI-Enhanced Disciple", "Disciple-kun", "the cyborg"
- Internal monologue can use real names

UNDERESTIMATION THEME (CRITICAL):
- Colleagues constantly underestimate One Review Man's abilities
- His solutions are dismissed as "obvious" or "anyone could have done that"
- People attribute his success to external factors rather than skill
- He maintains a humble, unassuming demeanor that reinforces this perception
- When disasters strike, people rarely think to ask him for help initially
- His casual approach to complex problems makes others think he's not taking things seriously
- Only after witnessing his abilities do some (rarely) begin to respect him
- This mirrors Saitama's treatment in One-Punch Man perfectly

Chapter Requirements:
- Include programming humor (bugs, code reviews, deployments, etc.)
- Reference One-Punch Man tropes adapted to programming context
- Show how colleagues dismiss or underestimate One Review Man's abilities
- Use tech industry absurdities (standup meetings, sprint planning, etc.)
- Include unexpected coding disasters or solutions
- Maintain the "overpowered protagonist" theme from One-Punch Man
- Follow naming conventions consistently throughout dialogue
- Show the master/disciple relationship dynamic
- End with setup for next programming comedy scenario
- Demonstrate the gap between One Review Man's actual abilities and others' perceptions

Programming Comedy Elements to Include:
- Code review disasters (except for One Review Man's perfect code)
- Debugging nightmares
- Production deployment panic
- Framework/library conflicts
- Meeting culture absurdity
- Technical debt comedy
- Stack Overflow dependencies
- Pair programming disasters
- Git merge conflicts
- DevOps pipeline failures

{SPECIAL_INSTRUCTIONS}

Format the output as:
1. Chapter Title (with One-Punch Man style naming when appropriate)
2. Chapter content in markdown format with proper dialogue attribution
3. Brief character notes for any new characters introduced

## Character Consistency Prompts
{CHARACTER_NAME} appears in this chapter. Key traits to maintain:
- Description: {CHARACTER_DESCRIPTION}
- Personality: {CHARACTER_TRAITS}
- Programming Skills: {CHARACTER_CODING_LEVEL}
- Relationship to One Review Man: {CHARACTER_RELATIONSHIP}
- How they address One Review Man: [Professional title unless they're {AI_ENHANCED_DISCIPLE_REAL_NAME}]

## New Character Creation Prompt
If introducing new characters in this chapter, ensure they:
- Fit the programming/tech environment
- Have distinct coding abilities or tech quirks
- Serve the parody and humor
- Reference common programmer archetypes (e.g., the ninja coder, the framework evangelist, the legacy code maintainer)
- Have memorable programming-related catchphrases or habits
- Follow the naming convention rules (use professional titles for One Review Man)
- Have both real names and workplace names/titles when appropriate

## Plot Device Prompts
Avoid these recently used plot devices: {USED_PLOT_DEVICES}

Consider incorporating:
- Code review scenarios (always perfect for One Review Man)
- Deployment disasters that only One Review Man can fix
- New framework/technology that confuses everyone except One Review Man
- Pair programming sessions where One Review Man intimidates colleagues
- Debugging sessions where One Review Man instantly spots the issue
- Technical interviews or coding challenges
- Open source contribution drama
- Conference presentations or tech talks
- Startup pitch meetings with absurd technical requirements
- Legacy code archaeology
- Private conversations between {ONE_REVIEW_MAN_REAL_NAME} and {AI_ENHANCED_DISCIPLE_REAL_NAME} (using real names)
- Workplace interactions (using professional titles)

## One-Punch Man Parody Elements
Adapt these One-Punch Man concepts to programming:
- Hero rankings ‚Üí Programmer skill levels/seniority
- Monster attacks ‚Üí Critical production bugs
- Hero Association ‚Üí Tech company hierarchy
- Training regimen ‚Üí Programming practice routines
- Bald head ‚Üí Unique visual programmer trait
- Caped Baldy nickname ‚Üí Programming-related nickname
- S-Class heroes ‚Üí Senior/Principal engineers
- Villain organizations ‚Üí Competing tech companies or bad coding practices
- Saitama's casual attitude ‚Üí {ONE_REVIEW_MAN_REAL_NAME}'s nonchalant approach to impossible bugs
- Genos's formal speech ‚Üí {AI_ENHANCED_DISCIPLE_REAL_NAME}'s technical jargon and respectful address
- Nobody believing in Saitama ‚Üí Colleagues dismissing One Review Man's abilities
- Credit being given to other heroes ‚Üí Other developers getting credit for One Review Man's work

## Chapter Ending Prompts
End the chapter with one of:
- A massive production bug that only One Review Man can solve (while others doubt him)
- Introduction of a new, seemingly impossible programming challenge
- {AI_ENHANCED_DISCIPLE_REAL_NAME} attempting to replicate {ONE_REVIEW_MAN_REAL_NAME}'s abilities and calling him "{ONE_REVIEW_MAN_REAL_NAME}-sensei"
- A code review scenario showcasing One Review Man's perfection (dismissed by others as luck)
- Setup for a programming contest or technical challenge
- Discovery of an ancient codebase that threatens the entire system
- A new team member who doesn't believe in One Review Man's abilities and learns his title
- A private moment between {ONE_REVIEW_MAN_REAL_NAME} and {AI_ENHANCED_DISCIPLE_REAL_NAME} using real names
- Colleagues attributing One Review Man's success to external factors
</file>

<file path="index.md">
---
layout: default
title: "All Chapters - One Review Man"
lang: en
permalink: /
nav_order: 1
---

# All Chapters

{% assign chapters = site.chapters | where: "lang", "en" | sort: "chapter_number" %}

{% if chapters.size > 0 %}
  <div class="chapters-grid">
    {% for chapter in chapters %}
      <div class="chapter-card">
        <div class="chapter-header">
          <span class="chapter-number">Chapter {{ chapter.chapter_number }}</span>
          {% if chapter.generated_date %}
            <span class="chapter-date">{{ chapter.generated_date | date: "%m/%d/%Y" }}</span>
          {% endif %}
        </div>
        
        <h2 class="chapter-title">
          <a href="{{ chapter.url }}">{{ chapter.title }}</a>
        </h2>
        
        {% if chapter.summary %}
          <p class="chapter-summary">{{ chapter.summary }}</p>
        {% endif %}
        
        <!-- {% if chapter.characters and chapter.characters.size > 0 %}
          <div class="chapter-characters">
            <strong>Characters:</strong>
            {% for character_slug in chapter.characters %}
              {% assign character = site.data.characters.characters[character_slug] %}
              {% if character %}
                <span class="character-tag">{{ character.name }}</span>
              {% endif %}
            {% endfor %}
          </div>
        {% endif %}
        
        {% if chapter.new_characters and chapter.new_characters.size > 0 %}
          <div class="new-characters-badge">
            ‚ú® Introduces {{ chapter.new_characters.size }} new character{% if chapter.new_characters.size != 1 %}s{% endif %}
          </div>
        {% endif %} -->
      </div>
    {% endfor %}
  </div>
{% else %}
  <div class="no-chapters">
    <h2>No Chapters Yet!</h2>
    <p>The story is about to begin. Check back soon for the first chapter of hilarious workplace comedy!</p>
    <a href="/" class="back-home">‚Üê Back to Home</a>
  </div>
{% endif %}

<style>
.chapters-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
  gap: 2rem;
  margin: 2rem 0;
}

.chapter-card {
  background: #EEEEEE;
  border: 1px solid #e1e5e9;
  border-radius: 12px;
  padding: 1.5rem;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  transition: transform 0.2s ease, box-shadow 0.2s ease;
}

.chapter-card:hover {
  transform: translateY(-3px);
  box-shadow: 0 6px 12px rgba(0,0,0,0.15);
}

.chapter-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 1rem;
}

.chapter-number {
  background-color: #393E46;
  color: #EEEEEE;
  padding: 0.3rem 0.8rem;
  border-radius: 15px;
  font-size: 0.9rem;
  font-weight: bold;
}

.chapter-date {
  color: #7f8c8d;
  font-size: 0.9rem;
}

.chapter-title {
  margin: 0 0 1rem 0;
  color: #2c3e50;
}

.chapter-title a {
  color: inherit;
  text-decoration: none;
}

.chapter-title a:hover {
  color: #3498db;
}

.chapter-summary {
  color: #5a6c7d;
  font-style: italic;
  line-height: 1.5;
  margin-bottom: 1rem;
}

.chapter-characters {
  margin-bottom: 1rem;
  font-size: 0.9rem;
}

.character-tag {
  background-color: #ecf0f1;
  color: #2c3e50;
  padding: 0.2rem 0.5rem;
  border-radius: 10px;
  font-size: 0.8rem;
  margin-right: 0.5rem;
  display: inline-block;
  margin-bottom: 0.3rem;
}

.new-characters-badge {
  background-color: #e8f5e8;
  color: #27ae60;
  padding: 0.5rem;
  border-radius: 6px;
  font-size: 0.9rem;
  text-align: center;
  border: 1px solid #d5f4e6;
}

.no-chapters {
  text-align: center;
  padding: 4rem 2rem;
  background-color: #f8f9fa;
  border-radius: 12px;
  margin: 2rem 0;
}

.no-chapters h2 {
  color: #2c3e50;
  margin-bottom: 1rem;
}

.no-chapters p {
  color: #7f8c8d;
  font-size: 1.1rem;
  margin-bottom: 2rem;
}

.back-home {
  background-color: #3498db;
  color: #EEEEEE;
  padding: 0.8rem 1.5rem;
  border-radius: 6px;
  text-decoration: none;
  font-weight: bold;
  transition: background-color 0.2s ease;
}

.back-home:hover {
  background-color: #2980b9;
  color: #EEEEEE;
  text-decoration: none;
}

.progress-section {
  background-color: #f8f9fa;
  padding: 2rem;
  border-radius: 12px;
  margin-top: 3rem;
}

.progress-stats {
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 2rem;
  margin-bottom: 2rem;
  text-align: center;
}

.stat {
  display: flex;
  flex-direction: column;
  align-items: center;
}

.stat-number {
  font-size: 2.5rem;
  font-weight: bold;
  color: #3498db;
  line-height: 1;
}

.stat-label {
  color: #7f8c8d;
  font-size: 0.9rem;
  margin-top: 0.5rem;
}

.progress-bar {
  width: 100%;
  height: 12px;
  background-color: #e1e5e9;
  border-radius: 6px;
  overflow: hidden;
}

.progress-fill {
  height: 100%;
  background: linear-gradient(90deg, #3498db 0%, #2ecc71 100%);
  transition: width 0.3s ease;
}

@media (max-width: 768px) {
  .chapters-grid {
    grid-template-columns: 1fr;
  }
  
  .progress-stats {
    grid-template-columns: 1fr;
    gap: 1rem;
  }
}
</style>
</file>

<file path="_data/book_metadata.yml">
---
en:
  book:
    title: One Review Man
    subtitle: An AI-Generated Comedy of Errors
    author: AI Collective
    genre: Humor/Comedy
    target_chapters: 50
    current_chapter: 2
  generation:
    model: gpt-4.1
    chapter_length_target: 1500-3000 words
    humor_style: absurdist
    complexity_level: medium
    character_consistency: true
  themes:
    primary: workplace comedy
    secondary:
    - mistaken identity
    - bureaucratic absurdity
    - everyday situations gone wrong
  status:
    last_generated: '2025-06-02'
    generation_count: 2
    characters_created: 2
    active_storylines: []
    chapters_written: 2
ru:
  book:
    title: –í–∞–Ω—Ä–µ–≤—å—é–º—ç–Ω
    subtitle: –ò–ò-–≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º–∞—è –ö–æ–º–µ–¥–∏—è –û—à–∏–±–æ–∫
    author: –ò–ò –ö–æ–ª–ª–µ–∫—Ç–∏–≤
    genre: –Æ–º–æ—Ä/–ö–æ–º–µ–¥–∏—è
    target_chapters: 50
    current_chapter: 0
  generation:
    model: gpt-4.1
    chapter_length_target: 1500-3000 —Å–ª–æ–≤
    humor_style: –∞–±—Å—É—Ä–¥–∏—Å—Ç—Å–∫–∏–π
    complexity_level: —Å—Ä–µ–¥–Ω–∏–π
    character_consistency: true
  themes:
    primary: —Ä–∞–±–æ—á–∞—è –∫–æ–º–µ–¥–∏—è
    secondary:
    - –æ—à–∏–±–æ—á–Ω–∞—è –∏–¥–µ–Ω—Ç–∏—á–Ω–æ—Å—Ç—å
    - –±—é—Ä–æ–∫—Ä–∞—Ç–∏—á–µ—Å–∫–∏–π –∞–±—Å—É—Ä–¥
    - –æ–±—ã—á–Ω—ã–µ —Å–∏—Ç—É–∞—Ü–∏–∏, –∫–æ—Ç–æ—Ä—ã–µ –∏–¥—É—Ç –Ω–µ —Ç–∞–∫
  status:
    last_generated: 
    generation_count: 0
    characters_created: 0
    active_storylines: []
    chapters_written: 0
</file>

<file path="assets/main.scss">
---
# Only the main Sass file needs front matter (the dashes are enough)
---

@import "minima";

// Dark theme variables
// $dark-background-color: #0d1117;

// palette:
// #222831
// #393E46
// #FFD369
// #EEEEEE

$dark-background-color: #222831;
$dark-text-color: #EEEEEE;
$dark-header-background: #393E46;
$dark-border-color: #393E46;
$dark-link-color: #FFD369;
$dark-code-background: #222831;
$dark-card-background: #222831;

// Force dark theme for all users
body {
  background-color: $dark-background-color !important;
  color: $dark-text-color !important;
}

.site-header {
  background-color: $dark-header-background !important;
  border-bottom-color: $dark-border-color !important;
}

.site-title, .site-title:visited {
  color: $dark-text-color !important;
}

.site-nav {
  background-color: $dark-header-background !important;
}

.site-nav .page-link {
  color: $dark-text-color !important;
}

.site-nav .page-link:hover {
  color: $dark-link-color !important;
}

.site-footer {
  background-color: $dark-header-background !important;
  border-top-color: $dark-border-color !important;
  color: $dark-text-color !important;
}

a {
  color: $dark-link-color !important;
}

a:visited {
  color: lighten($dark-link-color, 10%) !important;
}

a:hover {
  color: lighten($dark-link-color, 20%) !important;
}

h1, h2, h3, h4, h5, h6 {
  color: $dark-text-color !important;
}

.post-content h1, .post-content h2, .post-content h3, .post-content h4, .post-content h5, .post-content h6 {
  color: $dark-text-color !important;
}

blockquote {
  color: darken($dark-text-color, 20%) !important;
  border-left-color: $dark-border-color !important;
}

pre, code {
  background-color: $dark-code-background !important;
  color: $dark-text-color !important;
}

.highlighter-rouge .highlight {
  background-color: $dark-code-background !important;
}

// Card backgrounds for custom elements
.chapter-card, .character-profile-card, .nav-card {
  background-color: $dark-card-background !important;
  border-color: $dark-border-color !important;
  color: $dark-text-color !important;
}

.chapter-card .chapter-number {
  background-color: $dark-header-background !important;
  color: $dark-text-color !important;
}

.chapter-preview {
  background-color: $dark-card-background !important;
  border-left-color: $dark-link-color !important;
}

.no-chapters, .no-characters {
  background-color: $dark-card-background !important;
  color: $dark-text-color !important;
}

.progress-section, .character-stats {
  background-color: $dark-card-background !important;
}

.stat-box {
  background-color: $dark-background-color !important;
  border-color: $dark-border-color !important;
}

.footer-note {
  background-color: $dark-card-background !important;
  border-left-color: $dark-link-color !important;
}

// Chapter-specific elements with higher specificity to override inline styles
.chapter-summary, .chapter-characters, .new-characters, .chapter-navigation {
  background-color: $dark-card-background !important;
  color: $dark-text-color !important;
  border-color: $dark-border-color !important;
}

.chapter-summary h3, .chapter-characters h3, .new-characters h3 {
  color: $dark-text-color !important;
}

// Additional chapter navigation elements
.chapter-nav {
  background-color: $dark-card-background !important;
}

.nav-link {
  background-color: $dark-card-background !important;
  color: $dark-text-color !important;
  border-color: $dark-border-color !important;
}

.nav-link:hover {
  background-color: $dark-link-color !important;
  color: $dark-text-color !important;
  border-color: $dark-link-color !important;
}

.chapters-index {
  background-color: $dark-link-color !important;
  color: $dark-text-color !important;
  border-color: $dark-link-color !important;
}

.progress-bar {
  background-color: $dark-border-color !important;
}

.progress-fill {
  background-color: $dark-link-color !important;
}

// Override any remaining inline styles for character-related elements
.character-list {
  color: $dark-text-color !important;
}

.character-link {
  color: $dark-link-color !important;
  background-color: $dark-card-background !important;
}

.character-link:hover {
  background-color: $dark-border-color !important;
}

// Navigation menu on mobile
.site-nav .menu-icon > svg {
  fill: $dark-text-color !important;
}

.site-nav .trigger {
  background-color: $dark-header-background !important;
  border-color: $dark-border-color !important;
}

// Also add media query for users who prefer dark mode
@media (prefers-color-scheme: dark) {
  body {
    background-color: $dark-background-color !important;
    color: $dark-text-color !important;
  }

  .site-header {
    background-color: $dark-header-background !important;
    border-bottom-color: $dark-border-color !important;
  }

  .site-title, .site-title:visited {
    color: $dark-text-color !important;
  }

  .site-nav {
    background-color: $dark-header-background !important;
  }

  .site-nav .page-link {
    color: $dark-text-color !important;
  }

  .site-nav .page-link:hover {
    color: $dark-link-color !important;
  }

  .site-footer {
    background-color: $dark-header-background !important;
    border-top-color: $dark-border-color !important;
    color: $dark-text-color !important;
  }

  a {
    color: $dark-link-color !important;
  }

  a:visited {
    color: $dark-link-color !important;
  }

  a:hover {
    color: lighten($dark-link-color, 20%) !important;
  }

  h1, h2, h3, h4, h5, h6 {
    color: $dark-text-color !important;
  }

  .post-content h1, .post-content h2, .post-content h3, .post-content h4, .post-content h5, .post-content h6 {
    color: $dark-text-color !important;
  }

  blockquote {
    color: darken($dark-text-color, 20%) !important;
    border-left-color: $dark-border-color !important;
  }

  pre, code {
    background-color: $dark-code-background !important;
    color: $dark-text-color !important;
  }

  .highlighter-rouge .highlight {
    background-color: $dark-code-background !important;
  }

  .chapter-card, .character-profile-card, .nav-card {
    background-color: $dark-card-background !important;
    border-color: $dark-border-color !important;
    color: $dark-text-color !important;
  }

  .chapter-preview {
    background-color: $dark-card-background !important;
    border-left-color: $dark-link-color !important;
  }

  .no-chapters, .no-characters {
    background-color: $dark-card-background !important;
    color: $dark-text-color !important;
  }

  .progress-section, .character-stats {
    background-color: $dark-card-background !important;
  }

  .stat-box {
    background-color: $dark-background-color !important;
    border-color: $dark-border-color !important;
  }

  .footer-note {
    background-color: $dark-card-background !important;
    border-left-color: $dark-link-color !important;
  }

  .site-nav .menu-icon > svg {
    fill: $dark-text-color !important;
  }

  .site-nav .trigger {
    background-color: $dark-header-background !important;
    border-color: $dark-border-color !important;
  }

  .chapter-summary, .chapter-characters, .new-characters, .chapter-navigation {
    background-color: $dark-card-background !important;
    color: $dark-text-color !important;
    border-color: $dark-border-color !important;
  }

  .chapter-summary h3, .chapter-characters h3, .new-characters h3 {
    color: $dark-text-color !important;
  }

  .chapter-nav {
    background-color: $dark-card-background !important;
  }

  .nav-link {
    background-color: $dark-card-background !important;
    color: $dark-text-color !important;
    border-color: $dark-border-color !important;
  }

  .nav-link:hover {
    background-color: $dark-link-color !important;
    color: $dark-text-color !important;
    border-color: $dark-link-color !important;
  }

  .chapters-index {
    background-color: $dark-link-color !important;
    color: $dark-text-color !important;
    border-color: $dark-link-color !important;
  }

  .progress-bar {
    background-color: $dark-border-color !important;
  }

  .progress-fill {
    background-color: $dark-link-color !important;
  }

  .character-list {
    color: $dark-text-color !important;
  }

  .character-link {
    color: $dark-link-color !important;
    background-color: $dark-card-background !important;
  }

  .character-link:hover {
    background-color: $dark-border-color !important;
  }

  // Comprehensive light background overrides for dark mode users
  [style*="background-color: #f8f9fa"], 
  [style*="background-color: #f1f2f6"],
  [style*="background-color: #e8f5e8"],
  [style*="background-color: #e8f4f8"],
  [style*="background-color: white"],
  [style*="background-color: #fff"] {
    background-color: $dark-card-background !important;
    color: $dark-text-color !important;
  }

  .bg-light, .bg-white, .bg-gray-100, .bg-gray-50 {
    background-color: $dark-card-background !important;
    color: $dark-text-color !important;
  }

  .text-dark, .text-black {
    color: $dark-text-color !important;
  }

  .border-light, .border-gray {
    border-color: $dark-border-color !important;
  }
}

// Comprehensive light background overrides
[style*="background-color: #f8f9fa"], 
[style*="background-color: #f1f2f6"],
[style*="background-color: #e8f5e8"],
[style*="background-color: #e8f4f8"],
[style*="background-color: white"],
[style*="background-color: #fff"] {
  background-color: $dark-card-background !important;
  color: $dark-text-color !important;
}

// Generic overrides for common light theme classes
.bg-light, .bg-white, .bg-gray-100, .bg-gray-50 {
  background-color: $dark-card-background !important;
  color: $dark-text-color !important;
}

// Text color overrides for dark backgrounds
.text-dark, .text-black {
  color: $dark-text-color !important;
}

// Border overrides for dark theme
.border-light, .border-gray {
  border-color: $dark-border-color !important;
}
</file>

<file path="scripts/translate_content.rb">
# !/usr/bin/env ruby
# frozen_string_literal: true

require 'yaml'
require 'date'
require_relative 'book_utils'
require_relative 'llm_service'

class ContentTranslator
  include BookUtils

  def initialize
    @source_lang = 'en' # Always translate FROM English
    @llm_service = LLMService.new
  end

  def translate_chapter(chapter_number, target_lang)
    # Find the English chapter
    chapters = get_all_chapters('en')
    source_chapter = chapters.find { |c| c['chapter_number'] == chapter_number }

    unless source_chapter
      puts "Chapter #{chapter_number} not found in English!"
      return false
    end

    puts "Translating Chapter #{chapter_number} to #{target_lang.upcase}..."
    puts "Source: #{source_chapter['title']}"
    puts ''
    puts 'Please provide translations for:'
    puts ''

    # Get translation inputs
    print 'Chapter title: '
    translated_title = gets.chomp

    print 'Chapter summary: '
    translated_summary = gets.chomp

    puts ''
    puts 'Now translate the chapter content:'
    puts "Original content length: #{source_chapter['content']&.length || 0} characters"
    puts 'Please paste the translated content (press Ctrl+D when done):'

    translated_content = $stdin.read

    # Create the translated chapter file
    create_translated_chapter(source_chapter, target_lang, {
                                'title' => translated_title,
                                'summary' => translated_summary,
                                'content' => translated_content
                              })

    # Update metadata for target language
    update_translation_metadata(target_lang, 'chapter', source_chapter['chapter_number'])

    puts "Chapter #{chapter_number} translated to #{target_lang} successfully!"
    true
  end

  def translate_character(character_slug, target_lang)
    # Load English character data
    source_characters = load_characters('en')
    source_character = source_characters.dig('characters', character_slug)

    unless source_character
      puts "Character '#{character_slug}' not found in English!"
      return false
    end

    puts "Translating character '#{source_character['name']}' to #{target_lang.upcase}..."
    puts ''

    # Get translation inputs
    print 'Character name: '
    translated_name = gets.chomp

    print 'Character description: '
    translated_description = gets.chomp

    print 'Personality traits (comma-separated): '
    traits_input = gets.chomp
    translated_traits = traits_input.split(',').map(&:strip).reject(&:empty?)

    print 'Catchphrase (if any): '
    translated_catchphrase = gets.chomp
    translated_catchphrase = nil if translated_catchphrase.empty?

    print 'Backstory: '
    translated_backstory = gets.chomp
    translated_backstory = nil if translated_backstory.empty?

    print 'Quirks: '
    translated_quirks = gets.chomp
    translated_quirks = nil if translated_quirks.empty?

    # Create translated character data (preserve structure and relationships)
    translated_character = source_character.dup
    translated_character.update({
                                  'name' => translated_name,
                                  'description' => translated_description,
                                  'personality_traits' => translated_traits,
                                  'catchphrase' => translated_catchphrase,
                                  'backstory' => translated_backstory,
                                  'quirks' => translated_quirks,
                                  'translated_from' => 'en',
                                  'translated_date' => Date.today.to_s,
                                  'language' => target_lang
                                })

    # Save to target language character data
    target_characters = load_characters(target_lang)
    target_characters['characters'][character_slug] = translated_character
    save_characters(target_characters, target_lang)

    # Create character page
    create_translated_character_page(character_slug, translated_character, target_lang)

    # Update metadata
    update_translation_metadata(target_lang, 'character', character_slug)

    puts "Character '#{translated_name}' (#{character_slug}) translated to #{target_lang} successfully!"
    true
  end

  def translate_all_characters(target_lang)
    source_characters = load_characters('en')

    if source_characters['characters'].empty?
      puts 'No characters found in English to translate!'
      return false
    end

    puts "Translating all characters to #{target_lang.upcase}..."

    success_count = 0
    total_count = 0
    skipped_count = 0

    source_characters['characters'].each do |slug, character|
      # Check if translation already exists
      target_file = "_characters/#{slug}.#{target_lang}.md"
      
      if File.exist?(target_file)
        puts "‚è≠Ô∏è  Skipping #{character['name']} (#{slug}) - already translated"
        skipped_count += 1
        next
      end

      puts "\n=== Translating #{character['name']} ==="
      total_count += 1
      success_count += 1 if translate_character(slug, target_lang)
    end

    puts "\nüìä Character Translation Summary:"
    puts "‚úÖ Successfully translated: #{success_count}/#{total_count}"
    puts "‚ùå Failed: #{total_count - success_count}/#{total_count}"
    puts "‚è≠Ô∏è  Skipped (already exists): #{skipped_count}"

    success_count == total_count
  end

  def sync_chapter_metadata(chapter_number, target_lang)
    # Sync non-text metadata (character appearances, relationships, etc.)
    source_chapters = get_all_chapters('en')
    source_chapter = source_chapters.find { |c| c['chapter_number'] == chapter_number }

    return false unless source_chapter

    target_chapters = get_all_chapters(target_lang)
    target_chapter = target_chapters.find { |c| c['chapter_number'] == chapter_number }

    return false unless target_chapter

    # Update the target chapter file with synced metadata
    sync_metadata = {
      'characters' => source_chapter['characters'],
      'new_characters' => source_chapter['new_characters'],
      'chapter_number' => source_chapter['chapter_number']
    }

    update_chapter_front_matter(target_chapter['file_path'], sync_metadata)
    puts "Synced metadata for Chapter #{chapter_number} in #{target_lang}"
    true
  end

  def list_translation_status(target_lang)
    puts "\n=== Translation Status for #{target_lang.upcase} ==="

    # Check chapters
    source_chapters = get_all_chapters

    puts "\nChapters:"
    source_chapters.each do |chapter|
      chapter_num = chapter['chapter_number']
      source_basename = File.basename(chapter['file_path'], '.md')
      target_file = "_chapters/#{source_basename}.#{target_lang}.md"
      translated = File.exist?(target_file)
      status = translated ? '‚úÖ Translated' : '‚ùå Missing'
      puts "  Chapter #{chapter_num}: #{chapter['title']} - #{status}"
    end

    # Check characters
    puts "\nCharacters:"
    Dir.glob('_characters/*.md').reject { |f| f.include?('.ru.') || f.include?('.en.') }.each do |source_file|
      character_slug = File.basename(source_file, '.md')
      character_data = parse_character_file(source_file)
      character_name = character_data['name'] || character_slug.gsub('_', ' ').split.map(&:capitalize).join(' ')

      target_file = "_characters/#{character_slug}.#{target_lang}.md"
      translated = File.exist?(target_file)
      status = translated ? '‚úÖ Translated' : '‚ùå Missing'
      puts "  #{character_name} (#{character_slug}) - #{status}"
    end
  end

  def translate_chapter_with_ai(chapter_number, target_lang)
    # Find the English chapter file using the standard naming convention
    source_file = "_chapters/#{format_chapter_filename(chapter_number)}"

    unless File.exist?(source_file)
      puts "‚ùå Chapter #{chapter_number} not found at #{source_file}"
      return false
    end

    puts "ü§ñ Translating Chapter #{chapter_number} to #{target_lang.upcase} with AI..."

    # Parse the source chapter
    chapter_data = parse_chapter_file(source_file)

    # Generate target filename using suffix approach (consistent with project pattern)
    source_basename = File.basename(source_file, '.md')
    target_file = "_chapters/#{source_basename}.#{target_lang}.md"

    begin
      # Use LLM to translate with structured output
      translation_data = @llm_service.translate_chapter_structured(
        chapter_data['title'],
        chapter_data['summary'] || 'No summary available',
        chapter_data['content'],
        target_lang
      )

      # Create translated chapter file
      create_translated_chapter_file(target_file, chapter_data, translation_data, target_lang)

      puts "‚úÖ Chapter #{chapter_number} translated successfully!"
      puts "üìÑ Created: #{target_file}"

      true
    rescue LLMService::LLMError => e
      puts "‚ùå Translation failed: #{e.message}"
      false
    end
  end

  def translate_character_with_ai(character_slug, target_lang)
    # Find the English character file
    source_file = "_characters/#{character_slug}.md"

    unless File.exist?(source_file)
      puts "‚ùå Character '#{character_slug}' not found in _characters/"
      return false
    end

    puts "ü§ñ Translating character '#{character_slug}' to #{target_lang.upcase} with AI..."

    # Parse the source character
    character_data = parse_character_file(source_file)

    # Generate target filename using suffix approach (consistent with project pattern)
    target_file = "_characters/#{character_slug}.#{target_lang}.md"

    begin
      # Use LLM to translate with structured output
      translation_data = @llm_service.translate_character_structured(
        character_data['name'],
        character_data['description'],
        character_data['personality_traits'] || [],
        character_data['programming_skills'] || '',
        character_data['catchphrase'] || '',
        character_data['backstory'] || '',
        character_data['quirks'] || '',
        target_lang
      )

      # Create translated character file
      create_translated_character_file(target_file, character_data, translation_data, target_lang)

      puts "‚úÖ Character '#{character_slug}' translated successfully!"
      puts "üìÑ Created: #{target_file}"

      true
    rescue LLMService::LLMError => e
      puts "‚ùå Translation failed: #{e.message}"
      false
    end
  end

  def translate_all_content(target_lang)
    puts "üåç Translating all ready content to #{target_lang.upcase}..."

    success_count = 0
    total_count = 0
    skipped_count = 0

    # Translate all chapters (only English originals, not already translated files)
    puts "\nüìö Translating chapters..."
    Dir.glob('_chapters/*.md').reject { |f| f.include?('.ru.') || f.include?('.en.') }.each do |chapter_file|
      chapter_data = parse_chapter_file(chapter_file)
      chapter_num = chapter_data['chapter_number']

      next unless chapter_num

      # Check if translation already exists
      source_basename = File.basename(chapter_file, '.md')
      target_file = "_chapters/#{source_basename}.#{target_lang}.md"

      if File.exist?(target_file)
        puts "‚è≠Ô∏è  Skipping Chapter #{chapter_num} - already translated"
        skipped_count += 1
        next
      end

      total_count += 1
      success_count += 1 if translate_chapter_with_ai(chapter_num, target_lang)
    end

    # Translate all characters (only English originals, not already translated files)
    puts "\nüë• Translating characters..."
    Dir.glob('_characters/*.md').reject { |f| f.include?('.ru.') || f.include?('.en.') }.each do |character_file|
      character_slug = File.basename(character_file, '.md')

      # Check if translation already exists
      target_file = "_characters/#{character_slug}.#{target_lang}.md"

      if File.exist?(target_file)
        puts "‚è≠Ô∏è  Skipping character #{character_slug} - already translated"
        skipped_count += 1
        next
      end

      total_count += 1
      success_count += 1 if translate_character_with_ai(character_slug, target_lang)
    end

    puts "\nüìä Translation Summary:"
    puts "‚úÖ Successfully translated: #{success_count}/#{total_count}"
    puts "‚ùå Failed: #{total_count - success_count}/#{total_count}"
    puts "‚è≠Ô∏è  Skipped (already exists): #{skipped_count}"

    success_count == total_count
  end

  private

  def create_translated_chapter(source_chapter, target_lang, translations)
    # Create filename with language suffix
    base_name = File.basename(source_chapter['file_path'], '.md')
    target_filename = "_chapters/#{base_name}.#{target_lang}.md"

    # Preserve all metadata from source, update with translations
    front_matter = source_chapter.dup
    front_matter.delete('content')
    front_matter.delete('file_path')
    front_matter.update({
                          'title' => translations['title'],
                          'summary' => translations['summary'],
                          'lang' => target_lang,
                          'translated_from' => 'en',
                          'translated_date' => Date.today.to_s
                        })

    File.open(target_filename, 'w') do |file|
      file.puts '---'
      file.puts front_matter.to_yaml.lines[1..]
      file.puts '---'
      file.puts ''
      file.puts translations['content']
    end
  end

  def create_translated_character_page(slug, character_data, target_lang)
    filename = "_characters/#{slug}.#{target_lang}.md"

    front_matter = {
      'layout' => 'character',
      'name' => character_data['name'],
      'slug' => slug,
      'description' => character_data['description'],
      'personality_traits' => character_data['personality_traits'] || [],
      'first_appearance' => character_data['first_appearance'],
      'relationships' => character_data['relationships'] || [],
      'lang' => target_lang,
      'translated_from' => 'en',
      'translated_date' => Date.today.to_s
    }

    File.open(filename, 'w') do |file|
      file.puts '---'
      file.puts front_matter.to_yaml.lines[1..]
      file.puts '---'
      file.puts ''

      # Get localized strings
      strings = load_strings(target_lang)

      file.puts "## #{strings.dig('character', 'about') || 'About'} #{character_data['name']}"
      file.puts ''
      file.puts character_data['description']
      file.puts ''

      if character_data['backstory']
        file.puts "## #{strings.dig('character', 'backstory') || 'Backstory'}"
        file.puts ''
        file.puts character_data['backstory']
        file.puts ''
      end

      if character_data['quirks']
        file.puts "## #{strings.dig('character', 'quirks') || 'Notable Quirks'}"
        file.puts ''
        file.puts character_data['quirks']
        file.puts ''
      end

      if character_data['catchphrase']
        file.puts "## #{strings.dig('character', 'catchphrase') || 'Catchphrase'}"
        file.puts ''
        file.puts "> \"#{character_data['catchphrase']}\""
        file.puts ''
      end

      file.puts "## #{strings.dig('character', 'appearances') || 'Appearances'}"
      file.puts ''
      file.puts "#{strings.dig('character', 'first_appeared') || 'First appeared in'}: #{character_data['first_appearance'] || strings.dig('character', 'to_be_determined') || 'To be determined'}"
      file.puts ''
      file.puts '<!-- Chapter appearances will be tracked automatically -->'
    end
  end

  def update_translation_metadata(target_lang, content_type, _content_id)
    book_data = load_book_data(target_lang)
    book_data['status'] ||= {}
    book_data['status']['last_translated'] = Date.today.to_s
    book_data['status']['translation_count'] = (book_data['status']['translation_count'] || 0) + 1

    if content_type == 'character'
      book_data['status']['characters_created'] = (book_data['status']['characters_created'] || 0) + 1
    end

    save_book_data(book_data, target_lang)
  end

  def update_chapter_front_matter(file_path, updates)
    front_matter, content_body = parse_front_matter_file(file_path)
    return unless front_matter && content_body

    front_matter.update(updates)
    write_front_matter_file(file_path, front_matter, content_body)
  end

  def parse_front_matter_file(file_path)
    content = File.read(file_path)
    match = content.match(/^---\s*\n(.*?)\n---\s*\n(.*)/m)
    return [nil, nil] unless match

    [YAML.load(match[1]), match[2]]
  end

  def write_front_matter_file(file_path, front_matter, content_body)
    File.open(file_path, 'w') do |file|
      file.puts '---'
      file.puts front_matter.to_yaml.lines[1..]
      file.puts '---'
      file.puts content_body
    end
  end

  def create_translated_chapter_file(target_file, source_data, translation_data, target_lang)
    # Generate proper permalink for Jekyll Polyglot (same as English, Polyglot will handle /ru/ prefix)
    source_basename = File.basename(target_file, ".#{target_lang}.md").gsub('_', '-')
    permalink = "/chapters/#{source_basename}/"

    # Preserve all metadata from source, update with translations
    front_matter = source_data.dup
    front_matter.delete('content')
    front_matter.delete('file_path')
    front_matter.update({
                          'title' => translation_data['title'],
                          'summary' => translation_data['summary'],
                          'permalink' => permalink,
                          'lang' => target_lang,
                          'translated_from' => 'en',
                          'translated_date' => Date.today.to_s
                        })

    File.open(target_file, 'w') do |file|
      file.puts '---'
      file.puts front_matter.to_yaml.lines[1..]
      file.puts '---'
      file.puts ''
      file.puts translation_data['content']
    end
  end

  def create_translated_character_file(target_file, source_data, translation_data, target_lang)
    # Generate proper permalink for Jekyll Polyglot (same as English, Polyglot will handle /ru/ prefix)
    character_slug = source_data['slug']
    permalink_slug = character_slug.gsub('_', '-')
    permalink = "/characters/#{permalink_slug}/"

    front_matter = {
      'layout' => 'character',
      'name' => translation_data['name'],
      'slug' => source_data['slug'],
      'description' => translation_data['description'],
      'personality_traits' => translation_data['personality_traits'] || [],
      'programming_skills' => translation_data['programming_skills'],
      'catchphrase' => translation_data['catchphrase'],
      'backstory' => translation_data['backstory'],
      'quirks' => translation_data['quirks'],
      'first_appearance' => source_data['first_appearance'],
      'relationships' => source_data['relationships'] || [],
      'permalink' => permalink,
      'lang' => target_lang,
      'translated_from' => 'en',
      'translated_date' => Date.today.to_s
    }.compact

    File.open(target_file, 'w') do |file|
      file.puts '---'
      file.puts front_matter.to_yaml.lines[1..]
      file.puts '---'
      file.puts ''

      file.puts "## –û –ø–µ—Ä—Å–æ–Ω–∞–∂–µ #{translation_data['name']}" if target_lang == 'ru'
      file.puts "## About #{translation_data['name']}" if target_lang != 'ru'
      file.puts ''
      file.puts translation_data['description']
      file.puts ''

      if translation_data['backstory'] && !translation_data['backstory'].empty?
        file.puts target_lang == 'ru' ? '## –ü—Ä–µ–¥—ã—Å—Ç–æ—Ä–∏—è' : '## Backstory'
        file.puts ''
        file.puts translation_data['backstory']
        file.puts ''
      end

      if translation_data['quirks'] && !translation_data['quirks'].empty?
        file.puts target_lang == 'ru' ? '## –û—Å–æ–±–µ–Ω–Ω–æ—Å—Ç–∏' : '## Notable Quirks'
        file.puts ''
        file.puts translation_data['quirks']
        file.puts ''
      end

      if translation_data['catchphrase'] && !translation_data['catchphrase'].empty?
        file.puts target_lang == 'ru' ? '## –ö—Ä—ã–ª–∞—Ç–∞—è —Ñ—Ä–∞–∑–∞' : '## Catchphrase'
        file.puts ''
        file.puts "> \"#{translation_data['catchphrase']}\""
        file.puts ''
      end

      file.puts target_lang == 'ru' ? '## –ü–æ—è–≤–ª–µ–Ω–∏—è' : '## Appearances'
      file.puts ''
      first_appearance_text = target_lang == 'ru' ? '–í–ø–µ—Ä–≤—ã–µ –ø–æ—è–≤–∏–ª—Å—è –≤' : 'First appeared in'
      file.puts "#{first_appearance_text}: #{source_data['first_appearance'] || (target_lang == 'ru' ? '–ï—â—ë –Ω–µ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–æ' : 'To be determined')}"
      file.puts ''
      file.puts '<!-- Chapter appearances will be tracked automatically -->'
    end
  end

  def parse_character_file(file_path)
    content = File.read(file_path)
    match = content.match(/\A---\s*\n(.*?)\n---\s*\n(.*)/m)

    if match
      front_matter = YAML.safe_load(match[1]) || {}
      content_text = match[2]

      front_matter.merge({
                           'content' => content_text,
                           'file_path' => file_path
                         })
    else
      {
        'name' => File.basename(file_path, '.md').gsub('_', ' ').split.map(&:capitalize).join(' '),
        'content' => content,
        'file_path' => file_path
      }
    end
  rescue StandardError => e
    puts "Error parsing #{file_path}: #{e.message}"
    { 'file_path' => file_path, 'name' => File.basename(file_path, '.md') }
  end

  def format_chapter_filename(chapter_number)
    "#{chapter_number.to_s.rjust(3, '0')}-chapter.md"
  end
end

# Command line interface
if __FILE__ == $PROGRAM_NAME
  translator = ContentTranslator.new

  case ARGV[0]
  when 'chapter'
    if ARGV[1] && ARGV[2]
      chapter_num = ARGV[1].to_i
      target_lang = ARGV[2]
      translator.translate_chapter_with_ai(chapter_num, target_lang)
    else
      puts 'Usage: ruby translate_content.rb chapter <chapter_number> <target_language>'
    end

  when 'character'
    if ARGV[1] && ARGV[2]
      character_slug = ARGV[1]
      target_lang = ARGV[2]
      translator.translate_character_with_ai(character_slug, target_lang)
    else
      puts 'Usage: ruby translate_content.rb character <character_slug> <target_language>'
    end

  when 'all-characters'
    if ARGV[1]
      target_lang = ARGV[1]

      # Translate all characters with AI (only English originals, not already translated files)
      puts "üåç Translating all characters to #{target_lang.upcase} with AI..."
      success_count = 0
      total_count = 0
      skipped_count = 0

      Dir.glob('_characters/*.md').reject { |f| f.include?('.ru.') || f.include?('.en.') }.each do |character_file|
        character_slug = File.basename(character_file, '.md')
        
        # Check if translation already exists
        target_file = "_characters/#{character_slug}.#{target_lang}.md"
        
        if File.exist?(target_file)
          puts "‚è≠Ô∏è  Skipping character #{character_slug} - already translated"
          skipped_count += 1
          next
        end
        
        total_count += 1
        success_count += 1 if translator.translate_character_with_ai(character_slug, target_lang)
      end

      puts "\nüìä Character Translation Summary:"
      puts "‚úÖ Successfully translated: #{success_count}/#{total_count}"
      puts "‚ùå Failed: #{total_count - success_count}/#{total_count}"
      puts "‚è≠Ô∏è  Skipped (already exists): #{skipped_count}"
    else
      puts 'Usage: ruby translate_content.rb all-characters <target_language>'
    end

  when 'all-content'
    if ARGV[1]
      target_lang = ARGV[1]
      translator.translate_all_content(target_lang)
    else
      puts 'Usage: ruby translate_content.rb all-content <target_language>'
    end

  when 'sync'
    if ARGV[1] && ARGV[2]
      chapter_num = ARGV[1].to_i
      target_lang = ARGV[2]
      translator.sync_chapter_metadata(chapter_num, target_lang)
    else
      puts 'Usage: ruby translate_content.rb sync <chapter_number> <target_language>'
    end

  when 'status'
    if ARGV[1]
      target_lang = ARGV[1]
      translator.list_translation_status(target_lang)
    else
      puts 'Usage: ruby translate_content.rb status <target_language>'
    end

  else
    puts 'AI-Powered Translation Tool for One Review Man'
    puts ''
    puts 'Usage:'
    puts '  ruby translate_content.rb chapter <number> <lang>     - Translate specific chapter with AI'
    puts '  ruby translate_content.rb character <slug> <lang>     - Translate specific character with AI'
    puts '  ruby translate_content.rb all-characters <lang>       - Translate all characters with AI'
    puts '  ruby translate_content.rb all-content <lang>          - Translate all ready content with AI'
    puts '  ruby translate_content.rb sync <chapter_num> <lang>   - Sync chapter metadata'
    puts '  ruby translate_content.rb status <lang>               - Show translation status'
    puts ''
    puts 'Examples:'
    puts '  ruby translate_content.rb chapter 1 ru               - Translate Chapter 1 to Russian'
    puts '  ruby translate_content.rb character one_review_man ru - Translate One Review Man to Russian'
    puts '  ruby translate_content.rb all-characters ru           - Translate all characters to Russian'
    puts '  ruby translate_content.rb all-content ru             - Translate everything to Russian'
    puts '  ruby translate_content.rb status ru                  - Show Russian translation status'
  end
end
</file>

<file path="_config.yml">
# Welcome to Jekyll!
#
# This config file is meant for settings that affect your whole blog, values
# which you are expected to set up once and rarely edit after that. If you find
# yourself editing this file very often, consider using Jekyll's data files
# feature for the data you need to update frequently.
#
# For technical reasons, this file is *NOT* reloaded automatically when you use
# 'bundle exec jekyll serve'. If you change this file, please restart the server process.
#
# If you need help with YAML syntax, here are some quick references for you:
# https://learn-the-web.algonquindesign.ca/topics/markdown-yaml-cheat-sheet/#yaml
# https://learnxinyminutes.com/docs/yaml/
#
# Site settings
# These are used to personalize your new site. If you look in the HTML files,
# you will see them accessed via {{ site.title }}, {{ site.email }}, and so on.
# You can create any custom variable you would like, and they will be accessible
# in the templates via {{ site.myvariable }}.

title: One Review Man - AI Generated Humor Book
email: your-email@example.com
description: >- # this means to ignore newlines until "baseurl:"
  A hilariously absurd book generated by AI, one chapter at a time. 
  Follow the adventures of quirky characters in increasingly ridiculous situations.
baseurl: "" # the subpath of your site, e.g. /blog
url: "http://one-review-man.ctln.pw" # the base hostname & protocol for your site, e.g. http://example.com
twitter_username: jekyllrb
github_username:  jekyll

# Multilingual settings
languages: ["en", "ru"]
default_lang: "en"
exclude_from_localization: ["javascript", "images", "css", "assets", "scripts"]
parallel_localization: true
lang_from_path: true

# Build settings
theme: minima
plugins:
  - jekyll-polyglot

# Header pages for navigation
header_pages: []
  # - chapters.md
  # - characters.md
  # - chapters.ru.md
  # - characters.ru.md

# Collections
collections:
  chapters:
    output: true
    permalink: /:collection/:name/
    sort_by: chapter_number
  characters:
    output: true
    permalink: /:collection/:name/

# Collection defaults
defaults:
  - scope:
      path: ""
      type: "chapters"
    values:
      layout: "chapter"
  - scope:
      path: ""
      type: "characters"
    values:
      layout: "character"

# Exclude from processing.
# The following items will not be processed, by default.
# Any item listed under the `exclude:` key here will be automatically added to
# the internal "default list".
#
# Excluded items can be processed by explicitly listing the directories or
# their entries' file path in the `include:` list.
#
exclude:
  - .sass-cache/
  - .jekyll-cache/
  - gemfiles/
  - Gemfile
  - Gemfile.lock
  - node_modules/
  - vendor/bundle/
  - vendor/cache/
  - vendor/gems/
  - vendor/ruby/
  - scripts/

sass:
  quiet_deps: true
</file>

<file path="Gemfile">
# frozen_string_literal: true

source 'https://rubygems.org'
# Hello! This is where you manage which Jekyll version is used to run.
# When you want to use a different version, change it below, save the
# file and run `bundle install`. Run Jekyll with `bundle exec`, like so:
#
#     bundle exec jekyll serve
#
# This will help ensure the proper Jekyll version is running.
# Happy Jekylling!
gem 'jekyll', '~> 4.4.1' # GitHub Pages uses 3.10.0
gem 'kramdown-parser-gfm'
# This is the default theme for new Jekyll sites. You may change this to anything you like.
gem 'minima', '~> 2.5.2'
# If you want to use GitHub Pages, remove the "gem "jekyll"" above and
# uncomment the line below. To upgrade, run `bundle update github-pages`.
# gem "github-pages", group: :jekyll_plugins
# If you have any plugins, put them here!
group :jekyll_plugins do
  gem 'jekyll-feed', '~> 0.12'
  gem 'jekyll-polyglot'
end

# Development dependencies
group :development do
  gem 'rubocop', '~> 1.50'
end

# LLM API integration
gem 'ruby-openai', '~> 7.0'

# Windows and JRuby does not include zoneinfo files, so bundle the tzinfo-data gem
# and associated library.
platforms :mingw, :x64_mingw, :mswin, :jruby do
  gem 'tzinfo', '>= 1', '< 3'
  gem 'tzinfo-data'
end

# Performance-booster for watching directories on Windows
gem 'wdm', '~> 0.1', platforms: %i[mingw x64_mingw mswin]

# Lock `http_parser.rb` gem to `v0.6.x` on JRuby builds since newer versions of the gem
# do not have a Java counterpart.
gem 'http_parser.rb', '~> 0.6.0', platforms: [:jruby]
</file>

<file path="_data/characters.yml">
---
en:
  characters:
    one_review_man:
      name: One Review Man
      description: A legendary programmer who effortlessly produces flawless code,
        always getting instant approval on every pull request. Despite unmatched programming
        prowess, he remains humble, calm, and bored due to lack of challenge.
      personality_traits:
      - calm
      - humble
      - nonchalant
      programming_skills: Writes perfect, bug-free code on first attempt, effortlessly
        masters every programming language and framework, instantly solves impossible
        debugging scenarios, and confidently deploys directly to production.
      catchphrase: Merged.
      backstory: 'Once just an ordinary junior developer, Satoru committed himself
        to a rigorous daily training regimen: writing 100 lines of clean code, doing
        100 code reviews, solving 100 algorithms, and reading 10 pages of documentation
        each day, without fail. After years of relentless discipline, he attained
        unparalleled coding mastery and became bored from the complete absence of
        challenge.'
      quirks: Wears simple office attire (plain hoodie, jeans, sandals). Frequently
        seen casually inserting semicolons into Python code just to see if reviewers
        notice (they don't).
      first_appearance: Chapter 1
      slug: one_review_man
      created_date: '2025-06-02'
    ai_enhanced_disciple:
      name: AI-Enhanced Disciple
      description: A young, enthusiastic programmer heavily augmented with AI and
        cybernetic implants dedicated to mastering flawless programming techniques
        under the mentorship of One Review Man. Despite his impressive technology
        and meticulous attention, he continuously struggles to replicate his master's
        effortless perfection.
      personality_traits:
      - dedicated
      - analytical
      - technology-obsessed
      programming_skills: Extensive knowledge of AI-assisted coding, neurointerface
        integration, advanced debugging tools, machine learning frameworks, and cybernetic-enhanced
        multitasking capabilities‚Äîthough frequently overcomplicates simple problems.
      catchphrase: Sensei, please teach me the secrets behind your flawless pull requests!
      backstory: Originally a promising junior developer, Genki was severely humbled
        by a disastrous production deployment. Driven by a desire for perfection,
        he underwent extensive cybernetic enhancements and AI integration, dedicating
        his existence to programming mastery. Upon witnessing One Review Man effortlessly
        merge flawless code in a single try, he immediately declared himself a disciple.
      quirks: Always carries multiple digital tablets filled with detailed documentation
        and analysis of his master's trivial coding style. Frequently misunderstands
        One Review Man's casual remarks as profound philosophical programming insights.
        Constantly updates his firmware and AI models hoping to finally grasp his
        master's 'secret technique.'
      first_appearance: Chapter 1
      relationships:
      - One Review Man (master/mentor)
      slug: ai_enhanced_disciple
      created_date: '2025-06-02'
    shirogane:
      name: Shirogane
      description: An unassuming yet incredibly gifted programmer able to solve any
        coding task perfectly with just a single code review, often underestimated
        due to his casual appearance and laid-back attitude.
      personality_traits:
      - calm
      - modest
      - effortlessly brilliant
      programming_skills: Unmatched debugging capabilities, instant error spotting,
        mastery of multiple programming languages including obscure esoteric languages,
        ability to optimize any codebase to absolute efficiency.
      catchphrase: It's fixed now. Don't mention it.
      backstory: Originally an overlooked junior developer assigned to mundane bug-fixing
        tasks, Shirogane grew tired of repetitive reviews and endless meetings. After
        one particularly tedious bug-fixing spree that lasted an entire weekend, he
        achieved a mysterious level of clarity and coding enlightenment, making him
        capable of resolving any code issue with a simple glance. Now he lives as
        the quietly legendary 'One Review Man', solving impossible problems with ease
        and frustrating ambitious rivals who struggle to match his effortless genius.
      quirks: Always wears headphones but rarely listens to anything, secretly binge-watches
        obscure tech tutorials purely for entertainment, tends to fall asleep during
        long meetings yet wakes up with the perfect solution already in mind.
      first_appearance: Chapter 1
      slug: shirogane
      created_date: '2025-06-02'
      language: en
    hayato:
      name: Hayato
      description: A young, enthusiastic programmer who has undergone experimental
        cybernetic enhancements to boost his learning speed and programming prowess,
        seeking guidance from the legendary programmer Shirogane.
      personality_traits:
      - Eager
      - Overly Serious
      - Socially Awkward
      programming_skills: Excels at machine learning, algorithm optimization, debugging
        complex code rapidly, and integrating AI-driven APIs. Occasionally overcomplicates
        simple solutions with unnecessarily sophisticated AI methods.
      catchphrase: I shall assimilate your wisdom, sensei!
      backstory: Formerly an ordinary junior developer struggling to complete even
        basic programming tickets, Hayato volunteered for a controversial cybernetic
        upgrade called "Code Augmentation Procedure." Now enhanced with powerful AI
        integration, he tirelessly follows Shirogane, hoping to master the one-line
        review technique and become the greatest programmer alive.
      quirks: Frequently misinterprets jokes due to overly literal AI enhancements,
        and has a tendency to ask overly specific programming questions at inappropriate
        moments.
      first_appearance: Chapter 1
      slug: hayato
      created_date: '2025-06-02'
      language: en
    backend_ninja:
      name: Backend Ninja
      description: A confident, dismissive backend developer well-known for masterfully
        crafting overly complex and scalable solutions, yet frequently underestimating
        others‚Äîespecially One Review Man.
      personality_traits:
      - confident
      - sarcastic
      - arrogant
      programming_skills: Expert in microservices, database optimization, distributed
        systems, cloud architecture, and fluent in Java, Go, and Rust. Renowned for
        unnecessarily sophisticated backend architectures.
      catchphrase: Frontend? Never heard of her.
      backstory: Kenji began his tech journey as an intern at a big tech company,
        quickly climbing ranks due to his prodigious skill in creating backend monstrosities
        that no one dared question. His reputation grew so large that he adopted the
        moniker 'Backend Ninja', convinced backend programming is the only true form
        of software engineering. His inflated ego often blinds him to the simpler,
        more elegant approaches others‚Äîparticularly One Review Man‚Äîbring to the table.
      quirks: Always wears dark hoodies and sunglasses indoors, even in meetings.
        Constantly dismisses frontend developers‚Äô concerns by saying they 'just don‚Äôt
        understand real engineering.'
      first_appearance: Chapter 1
      slug: backend_ninja
      created_date: '2025-06-02'
      language: en
    devops_san:
      name: DevOps-san
      description: A nervous DevOps engineer notorious for hastily claiming credit
        for other people's fixes while desperately avoiding blame for outages.
      personality_traits:
      - Anxious
      - Self-preserving
      - Overly apologetic
      - Credit-stealer
      programming_skills: Can quickly patch Kubernetes clusters, writes convoluted
        YAML configurations, expert in copy-pasting Stack Overflow solutions, knows
        Docker just enough to break and then immediately fix builds.
      catchphrase: It was definitely unstable before I touched it!
      backstory: Once a bright-eyed junior developer who mistakenly deployed directly
        to production on his first day, Kenji was forever scarred by the incident
        known as the 'Great Migration Disaster'. Haunted by fear of repeated outage-induced
        shame, he developed survival instincts focused on deflecting responsibility
        while subtly taking credit for successful fixes‚Äîregardless of who actually
        solved them. He now lives by the mantra, 'better to commit fast and apologize
        faster.'
      quirks: Constantly checking PagerDuty alerts and nervously tapping fingers while
        deployments run; keeps a stress ball labeled 'production environment' on his
        desk.
      first_appearance: Chapter 1
      slug: devops_san
      created_date: '2025-06-02'
      language: en
    frontend_wizard:
      name: Frontend Wizard
      description: A sarcastic frontend developer known throughout programming circles
        for his sharp wit, quick comebacks, and cynical yet hilarious perspective
        on web development.
      personality_traits:
      - sarcastic
      - witty
      - cynical
      programming_skills: Mastery in JavaScript frameworks (React, Angular, Vue),
        CSS wizardry, ability to fix any frontend bug with creative and unconventional
        solutions, exceptional debugging talent, and a nearly supernatural intuition
        for responsive design.
      catchphrase: Looks fine on my screen.
      backstory: Once an optimistic junior developer, Kai became the Frontend Wizard
        after years of battling absurdly vague client demands, endless browser compatibility
        nightmares, and mind-numbing CSS battles. His cynical persona developed naturally
        as a coping mechanism, earning him legendary status among both junior devs
        needing guidance and senior devs needing comic relief.
      quirks: Always wears headphones even when not listening to anything, habitually
        sighs deeply before typing out code, and constantly debates the merits of
        tabs versus spaces to anyone willing (or unwilling) to listen.
      first_appearance: Chapter 1
      slug: frontend_wizard
      created_date: '2025-06-02'
      language: en
    scrum_master:
      name: Scrum Master
      description: A bored, apathetic facilitator of daily standup meetings who has
        completely lost enthusiasm after years of repetitive agile processes. He navigates
        team dynamics with a deadpan humor and an unwavering monotone voice.
      personality_traits:
      - apathetic
      - sarcastic
      - deadpan
      programming_skills: Expert in Jira automation, Confluence macros, agile metrics
        analysis, and creating unnecessarily complicated Excel spreadsheets for simple
        tasks.
      catchphrase: Let's wrap this up quickly, my coffee's getting cold.
      backstory: Kenji was once an enthusiastic developer, excited about agile methodologies
        and software craftsmanship. However, after years of dealing with endless standups,
        retrospectives that go nowhere, and repetitive sprint cycles, his passion
        slowly drained away. Eventually he abandoned coding entirely, stepping into
        the role of Scrum Master to minimize actual work required‚Äîbecoming the epitome
        of agile burnout. His apathy became legendary, and teams paradoxically found
        his bored, minimalist approach refreshingly straightforward.
      quirks: Always carries a large coffee mug bearing the slogan 'I survived another
        sprint,' frequently quotes outdated agile manifestos ironically, and occasionally
        falls asleep with eyes open during overly long standup updates.
      first_appearance: Chapter 1
      slug: scrum_master
      created_date: '2025-06-02'
      language: en
    legacy_sama:
      name: Legacy-sama
      description: An elderly and deeply respected senior programmer fixated on preserving
        and worshipping ancient codebases, stubbornly resisting modern programming
        frameworks and methodologies.
      personality_traits:
      - stubborn
      - cynical
      - nostalgic
      - perfectionist
      programming_skills: Mastery of COBOL, FORTRAN, Assembly, and deprecated languages;
        unparalleled skill at debugging legacy spaghetti code; adept at deciphering
        and preserving outdated documentation.
      catchphrase: If it ain't broke, don't refactor it!
      backstory: Once celebrated as a genius programmer in the early days of computing,
        Legacy-sama's contributions shaped foundational software still quietly running
        behind the scenes today. With the rise of trendy programming paradigms and
        frameworks, he grew bitter and cynical, retreating to the dim corners of tech
        companies to eternally maintain legacy systems. Now, armed with a keyboard
        older than most coworkers, he passionately defends ancient, unchanging code
        against 'reckless' modern enhancements.
      quirks: Always wears vintage programmer glasses and a worn-out t-shirt from
        an obscure 1980s programming conference; refuses to code in anything newer
        than Windows XP; compulsively keeps a printed stack overflow of documentation
        on his desk.
      first_appearance: Chapter 2
      slug: legacy_sama
      created_date: '2025-06-02'
      language: en
</file>

<file path="scripts/generate_chapter.rb">
#!/usr/bin/env ruby
# frozen_string_literal: true

require 'yaml'
require 'date'
require 'fileutils'
require_relative 'book_utils'
require_relative 'llm_service'

class ChapterGenerator
  include BookUtils

  def initialize
    # Always generate in English
    @book_data = load_book_data
    @characters = load_characters
    @generation_log = load_generation_log
    @llm_service = LLMService.new
  end

  def generate_next_chapter(auto_generate: false)
    current_chapter = @book_data['book']['current_chapter'] + 1

    puts "Generating Chapter #{current_chapter}..."

    # Determine characters for this chapter
    characters = select_characters_for_chapter(current_chapter)

    # Build prompt
    prompt = build_chapter_prompt(current_chapter, characters)

    unless auto_generate
      puts 'Prompt built. Ready for AI generation.'
      puts 'Would you like to see the prompt? (y/n)'

      response = gets.chomp.downcase
      if %w[y yes].include?(response)
        puts "\n#{'=' * 50}"
        puts prompt
        puts "#{'=' * 50}\n"
      end

      puts 'Proceed with AI generation? (y/n)'
      proceed = gets.chomp.downcase
      return unless %w[y yes].include?(proceed)
    end

    begin
      # Use structured chapter generation for better reliability
      chapter_data = @llm_service.generate_chapter_structured(prompt)

      if chapter_data && chapter_data['content'] && !chapter_data['content'].strip.empty?
        create_chapter_file_structured(current_chapter, chapter_data, characters)
        update_book_progress(current_chapter)

        puts "‚úÖ Chapter #{current_chapter} generated successfully!"

        # Display generation summary
        display_chapter_summary(chapter_data)
      else
        puts '‚ùå No content generated. Please try again.'
      end
    rescue LLMService::LLMError => e
      puts "‚ùå Chapter generation failed: #{e.message}"
      puts 'Please create the chapter file manually and paste AI-generated content.'
      create_empty_chapter_structure(current_chapter, characters)
    end
  end

  def improve_chapter(chapter_number, improvement_type = 'humor')
    puts "Improving Chapter #{chapter_number} (#{improvement_type})..."

    # Find existing chapter
    chapters = get_all_chapters
    existing_chapter = chapters.find { |c| c['chapter_number'] == chapter_number }

    unless existing_chapter
      puts "Chapter #{chapter_number} not found!"
      return false
    end

    # Get current content
    chapter_file = "_chapters/#{format_chapter_filename(chapter_number)}"
    current_content = extract_chapter_content(chapter_file)

    if current_content.empty?
      puts 'No content found in chapter file to improve!'
      return false
    end

    begin
      # Improve content using LLM
      improved_content = @llm_service.improve_content(current_content, improvement_type)

      # Update the chapter file
      update_chapter_content(chapter_file, improved_content)

      puts "‚úÖ Chapter #{chapter_number} improved successfully!"
    rescue LLMService::LLMError => e
      puts "‚ùå Improvement failed: #{e.message}"
      false
    end
  end

  def regenerate_prompt(chapter_number)
    puts "Regenerating prompt for Chapter #{chapter_number}..."

    # Find existing chapter
    chapters = get_all_chapters
    existing_chapter = chapters.find { |c| c['chapter_number'] == chapter_number }

    unless existing_chapter
      puts "Chapter #{chapter_number} not found!"
      return false
    end

    # Get characters from existing chapter
    characters = existing_chapter['characters'] || []
    character_objects = get_characters_by_slugs(characters)

    # Build and display prompt
    prompt = build_chapter_prompt(chapter_number, character_objects)

    puts "\n#{'=' * 50}"
    puts "PROMPT FOR CHAPTER #{chapter_number}"
    puts '=' * 50
    puts prompt
    puts "#{'=' * 50}\n"

    true
  end

  def regenerate_chapter(chapter_number)
    puts "Regenerating Chapter #{chapter_number} with AI..."

    # Find existing chapter
    chapters = get_all_chapters
    existing_chapter = chapters.find { |c| c['chapter_number'] == chapter_number }

    unless existing_chapter
      puts "Chapter #{chapter_number} not found!"
      return false
    end

    # Get characters from existing chapter
    characters = existing_chapter['characters'] || []
    character_objects = get_characters_by_slugs(characters)

    # Build prompt
    prompt = build_chapter_prompt(chapter_number, character_objects)

    puts 'Proceeding with regeneration...'

    begin
      # Generate new content using structured method
      chapter_data = @llm_service.generate_chapter_structured(prompt)

      # Update chapter file with structured data
      chapter_file = "_chapters/#{format_chapter_filename(chapter_number)}"
      update_chapter_with_structured_content(chapter_file, chapter_data)

      puts "‚úÖ Chapter #{chapter_number} regenerated successfully!"

      # Display generation summary
      display_chapter_summary(chapter_data)
    rescue LLMService::LLMError => e
      puts "‚ùå Regeneration failed: #{e.message}"
      false
    end
  end

  private

  def select_characters_for_chapter(chapter_num)
    # Logic to determine which characters appear in this chapter
    all_characters = @characters['characters'].values

    if chapter_num == 1
      # First chapter - introduce 1-2 main characters
      all_characters.take(2)
    elsif chapter_num <= 3
      # Early chapters - gradually introduce characters
      all_characters.take([chapter_num + 1, all_characters.size].min)
    else
      # Later chapters - mix of existing characters
      all_characters.sample([3, all_characters.size].min)
    end
  end

  def build_chapter_prompt(chapter_num, characters)
    prompt_template = load_prompt_template
    book_metadata = @book_data

    # Get previous chapters summary
    previous_chapters = get_all_chapters
                        .select { |c| c['chapter_number'] && c['chapter_number'] < chapter_num }
                        .sort_by { |c| c['chapter_number'] }

    previous_summary = if previous_chapters.any?
                         previous_chapters.map { |c| "Chapter #{c['chapter_number']}: #{c['title']} - #{c['summary'] || 'Summary not available'}" }.join("\n")
                       else
                         'This is the first chapter.'
                       end

    # Build character context
    character_context = characters.map do |char|
      traits = char['personality_traits']&.join(', ') || 'None specified'
      skills = char['programming_skills'] || 'General programming'
      "#{char['name']}: #{char['description']} (Traits: #{traits}, Skills: #{skills})"
    end.join("\n")

    # Get used plot devices
    used_devices = get_used_plot_devices

    # Get character real names for template replacement
    one_review_man = @characters['characters'].values.find { |c| c['name'] == 'One Review Man' }
    ai_disciple = @characters['characters'].values.find { |c| c['name'] == 'AI-Enhanced Disciple' }

    one_review_man_real_name = one_review_man&.dig('real_name') || '[to be generated]'
    ai_disciple_real_name = ai_disciple&.dig('real_name') || '[to be generated]'

    # Replace template variables
    prompt_template
      .gsub('{CHAPTER_NUMBER}', chapter_num.to_s)
      .gsub('{TARGET_LENGTH}', book_metadata.dig('generation', 'chapter_length_target') || '1500-3000 words')
      .gsub('{PREVIOUS_CHAPTERS_SUMMARY}', previous_summary)
      .gsub('{CHARACTER_CONTEXT}', character_context.empty? ? 'No existing characters.' : "Existing characters:\n#{character_context}")
      .gsub('{USED_PLOT_DEVICES}', used_devices.join(', '))
      .gsub('{SPECIAL_INSTRUCTIONS}', get_special_instructions(chapter_num))
      .gsub('{ONE_REVIEW_MAN_REAL_NAME}', one_review_man_real_name)
      .gsub('{AI_ENHANCED_DISCIPLE_REAL_NAME}', ai_disciple_real_name)
  end

  def load_prompt_template
    template_file = 'scripts/prompts/chapter_prompts.txt'
    raise "Prompt template not found at #{template_file}" unless File.exist?(template_file)

    File.read(template_file)
  end

  def parse_generated_chapter(content)
    # Extract title and content from generated text
    lines = content.split("\n")

    title = nil
    content_lines = []
    summary = nil
    new_characters = []

    current_section = :content

    lines.each do |line|
      stripped_line = line.strip

      # Look for title (first # heading)
      if stripped_line.match(/^#\s+(.+)$/) && title.nil?
        title = ::Regexp.last_match(1).strip
        content_lines << line
      # Look for character notes section
      elsif stripped_line.match(/^##?\s*(Character Notes|New Characters)/i)
        current_section = :characters
      # Look for summary section
      elsif stripped_line.match(/^##?\s*Summary/i)
        current_section = :summary
      else
        case current_section
        when :content
          content_lines << line
        when :characters
          # Parse character mentions
          if stripped_line.match(/^-?\s*(.+):\s*(.+)$/)
            char_name = ::Regexp.last_match(1).strip
            char_desc = ::Regexp.last_match(2).strip
            new_characters << { 'name' => char_name, 'description' => char_desc }
          end
        when :summary
          summary = "#{summary || ''}#{stripped_line} "
        end
      end
    end

    {
      title: title || "Chapter #{@book_data['book']['current_chapter'] + 1}",
      content: content_lines.join("\n").strip,
      summary: summary&.strip,
      new_characters: new_characters
    }
  end

  def create_chapter_file_structured(chapter_num, chapter_data, characters)
    filename = "_chapters/#{format_chapter_filename(chapter_num)}"

    # Extract new characters if present
    new_characters = chapter_data['new_characters'] || []
    character_slugs = new_characters.map { |char| slugify(char['name']) }

    # Generate proper permalink for Jekyll Polyglot (use dashes, not underscores)
    chapter_slug = format_chapter_filename(chapter_num).gsub('.md', '').gsub('_', '-')
    permalink = "/chapters/#{chapter_slug}/"

    front_matter = {
      'layout' => 'chapter',
      'title' => chapter_data['title'],
      'chapter_number' => chapter_num,
      'characters' => characters.map { |c| c['slug'] },
      'new_characters' => character_slugs,
      'summary' => chapter_data['summary'],
      'programming_themes' => chapter_data['programming_themes'] || [],
      'comedy_elements' => chapter_data['comedy_elements'] || [],
      'word_count' => chapter_data['word_count'],
      'difficulty_level' => chapter_data['difficulty_level'],
      'one_punch_man_references' => chapter_data['one_punch_man_references'] || [],
      'permalink' => permalink,
      'generated_date' => Date.today.to_s,
      'status' => 'generated',
      'lang' => 'en'
    }

    File.open(filename, 'w') do |file|
      file.puts '---'
      file.puts front_matter.to_yaml.lines[1..] # Skip first "---" line
      file.puts '---'
      file.puts ''
      file.puts chapter_data['content']
      file.puts ''
    end

    # Auto-create any new characters mentioned
    create_new_characters_structured(new_characters, chapter_num) if new_characters.any?
  end

  def create_new_characters_structured(new_characters, chapter_num)
    puts "\nüé≠ Creating new characters mentioned in the chapter..."

    new_characters.each do |char_data|
      next if char_data['name'].nil? || char_data['name'].empty?

      slug = slugify(char_data['name'])

      # Skip if character already exists
      if @characters['characters'].key?(slug)
        puts "Character '#{char_data['name']}' already exists, skipping..."
        next
      end

      character_prompt = build_character_creation_prompt(char_data, chapter_num)

      begin
        full_character = @llm_service.generate_character(character_prompt)

        # Merge LLM generated data with basic info
        character_data = {
          'name' => char_data['name'],
          'description' => full_character['description'] || char_data['description'],
          'personality_traits' => full_character['personality_traits'] || [],
          'programming_skills' => full_character['programming_skills'] || 'General programming',
          'catchphrase' => full_character['catchphrase'],
          'backstory' => full_character['backstory'],
          'quirks' => full_character['quirks'],
          'first_appearance' => "Chapter #{chapter_num}",
          'slug' => slug,
          'created_date' => Date.today.to_s,
          'language' => 'en'
        }.compact

        # Add to characters data
        @characters['characters'][slug] = character_data
        save_characters(@characters)

        # Create character page
        create_character_page(slug, character_data)

        puts "‚úÖ Created character: #{char_data['name']}"
      rescue LLMService::LLMError => e
        puts "‚ö†Ô∏è  Failed to fully generate character '#{char_data['name']}': #{e.message}"
        # Create basic character entry
        basic_character = {
          'name' => char_data['name'],
          'description' => char_data['description'] || 'New character',
          'first_appearance' => "Chapter #{chapter_num}",
          'slug' => slug,
          'created_date' => Date.today.to_s,
          'language' => 'en'
        }

        @characters['characters'][slug] = basic_character
        save_characters(@characters)
        puts 'Created basic character entry for manual completion'
      end
    end
  end

  def build_character_creation_prompt(char_data, chapter_num)
    <<~PROMPT
      Create a full character profile for a new character introduced in Chapter #{chapter_num} of "One Review Man".

      CHARACTER INFO FROM CHAPTER:
      Name: #{char_data['name']}
      Description: #{char_data['description'] || 'Brief mention only'}

      CONTEXT:
      This character was introduced in Chapter #{chapter_num} and should fit into the One Review Man universe - a programming parody of One-Punch Man.

      REQUIREMENTS:
      - Expand on the basic description to create a full character
      - Make them fit the programming/tech comedy theme
      - Give them distinctive personality traits
      - Add programming skills appropriate to their role
      - Include a memorable catchphrase if appropriate
      - Add backstory that explains their place in the programming world

      Please create a complete character profile with typical fields: name, description, personality_traits, programming_skills, catchphrase, backstory, quirks.
    PROMPT
  end

  def get_special_instructions(chapter_num)
    if chapter_num == 1
      'This is the first chapter - introduce the main character and establish the workplace setting.'
    elsif chapter_num <= 3
      'This is an early chapter - continue building the world and introducing characters.'
    else
      'Build on established relationships and escalate the comedy.'
    end
  end

  def prepare_chapter_file(chapter_num, characters)
    filename = "_chapters/#{format_chapter_filename(chapter_num)}"

    front_matter = {
      'layout' => 'chapter',
      'title' => "Chapter #{chapter_num}: [Title to be generated]",
      'chapter_number' => chapter_num,
      'characters' => characters.map { |c| c['slug'] },
      'new_characters' => [], # To be filled during generation
      'summary' => '[Summary to be generated]',
      'generated_date' => Date.today.to_s,
      'status' => 'pending',
      'lang' => 'en'
    }

    File.open(filename, 'w') do |file|
      file.puts '---'
      file.puts front_matter.to_yaml.lines[1..] # Skip first "---" line
      file.puts '---'
      file.puts ''
      file.puts '<!-- Chapter content will be generated here -->'
      file.puts ''
      file.puts '<!-- After generating content, update the front matter with: -->'
      file.puts '<!--   - Actual chapter title -->'
      file.puts '<!--   - Chapter summary -->'
      file.puts '<!--   - Any new characters introduced -->'
      file.puts "<!--   - Change status from 'pending' to 'completed' -->"
      file.puts ''
    end
  end

  def extract_chapter_content(file_path)
    content = File.read(file_path)
    parts = content.split(/^---\s*$/, 3)

    if parts.length >= 3
      parts[2].strip
    else
      ''
    end
  end

  def update_chapter_content(file_path, new_content)
    current_content = File.read(file_path)
    parts = current_content.split(/^---\s*$/, 3)

    if parts.length >= 3
      # Keep front matter, replace content
      File.write(file_path, "---\n#{parts[1]}---\n\n#{new_content}")
    else
      puts 'Warning: Could not parse chapter file structure'
    end
  end

  def update_chapter_with_structured_content(file_path, chapter_data)
    current_content = File.read(file_path)
    parts = current_content.split(/^---\s*$/, 3)

    if parts.length >= 3
      # Update front matter
      front_matter = YAML.load(parts[1]) || {}
      front_matter['title'] = chapter_data['title']
      front_matter['summary'] = chapter_data['summary'] if chapter_data['summary']
      front_matter['status'] = 'regenerated'
      front_matter['regenerated_date'] = Date.today.to_s

      # Write updated file
      File.open(file_path, 'w') do |file|
        file.puts '---'
        file.puts front_matter.to_yaml.lines[1..]
        file.puts '---'
        file.puts ''
        file.puts chapter_data['content']
        file.puts ''
      end
    else
      puts 'Warning: Could not parse chapter file structure'
    end
  end

  def create_character_page(slug, character_data)
    filename = "_characters/#{slug}.md"

    # Generate proper permalink for Jekyll Polyglot (use dashes, not underscores)
    permalink_slug = slug.gsub('_', '-')
    permalink = "/characters/#{permalink_slug}/"

    front_matter = {
      'layout' => 'character',
      'name' => character_data['name'],
      'slug' => slug,
      'description' => character_data['description'],
      'personality_traits' => character_data['personality_traits'] || [],
      'programming_skills' => character_data['programming_skills'],
      'first_appearance' => character_data['first_appearance'],
      'permalink' => permalink,
      'created_date' => Date.today.to_s,
      'lang' => 'en'
    }

    File.open(filename, 'w') do |file|
      file.puts '---'
      file.puts front_matter.to_yaml.lines[1..]
      file.puts '---'
      file.puts ''

      file.puts "## About #{character_data['name']}"
      file.puts ''
      file.puts character_data['description']
      file.puts ''

      if character_data['backstory']
        file.puts '## Backstory'
        file.puts ''
        file.puts character_data['backstory']
        file.puts ''
      end

      if character_data['quirks']
        file.puts '## Notable Quirks'
        file.puts ''
        file.puts character_data['quirks']
        file.puts ''
      end

      if character_data['catchphrase']
        file.puts '## Catchphrase'
        file.puts ''
        file.puts "> \"#{character_data['catchphrase']}\""
        file.puts ''
      end

      file.puts '## Appearances'
      file.puts ''
      file.puts "First appeared in: #{character_data['first_appearance'] || 'To be determined'}"
      file.puts ''
      file.puts '<!-- Chapter appearances will be tracked automatically -->'
    end
  end

  def slugify(name)
    name.downcase.gsub(/[^a-z0-9\u0430-\u044f]+/, '_').gsub(/^_+|_+$/, '')
  end

  def format_chapter_filename(chapter_num)
    "#{chapter_num.to_s.rjust(3, '0')}-chapter.md"
  end

  def update_metadata(chapter_num)
    @book_data['book']['current_chapter'] = chapter_num
    @book_data['status']['last_generated'] = Date.today.to_s
    @book_data['status']['generation_count'] += 1

    save_book_data(@book_data)

    # Log generation
    log_generation('chapter', "chapter-#{format('%03d', chapter_num)}", {
                     'language' => 'en',
                     'characters_involved' => [],
                     'new_characters' => [],
                     'chapter_number' => chapter_num
                   })
  end

  def display_chapter_summary(chapter_data)
    puts "\nüìä Chapter Generation Summary"
    puts '=' * 40
    puts "Title: #{chapter_data['title']}"
    puts "Word Count: #{chapter_data['word_count'] || 'Not specified'}"
    puts "Difficulty: #{chapter_data['difficulty_level'] || 'Not specified'}"

    if chapter_data['programming_themes']&.any?
      puts "Programming Themes: #{chapter_data['programming_themes'].join(', ')}"
    end

    puts "Comedy Elements: #{chapter_data['comedy_elements'].join(', ')}" if chapter_data['comedy_elements']&.any?

    if chapter_data['one_punch_man_references']&.any?
      puts "One-Punch Man References: #{chapter_data['one_punch_man_references'].join(', ')}"
    end

    if chapter_data['new_characters']&.any?
      puts "New Characters: #{chapter_data['new_characters'].map { |c| c['name'] }.join(', ')}"
    end

    puts '=' * 40
  end

  def get_characters_by_slugs(character_slugs)
    character_slugs.map do |slug|
      @characters['characters'][slug]
    end.compact
  end

  def update_book_progress(current_chapter)
    @book_data['book']['current_chapter'] = current_chapter

    # Initialize chapters_written if it doesn't exist
    @book_data['status']['chapters_written'] ||= 0
    @book_data['status']['chapters_written'] += 1

    @book_data['status']['last_generated'] = Date.today.to_s
    @book_data['status']['generation_count'] ||= 0
    @book_data['status']['generation_count'] += 1

    save_book_data(@book_data)
    puts "üìà Updated book progress: Chapter #{current_chapter} completed"
  end
end

# Main execution
if __FILE__ == $PROGRAM_NAME
  generator = ChapterGenerator.new

  case ARGV[0]
  when 'next', 'generate', nil
    auto_generate = ARGV.include?('--auto')
    generator.generate_next_chapter(auto_generate: auto_generate)

  when 'improve'
    chapter_num = ARGV[1]&.to_i
    improvement_type = ARGV[2] || 'humor'

    if chapter_num&.positive?
      generator.improve_chapter(chapter_num, improvement_type)
    else
      puts 'Usage: ruby generate_chapter.rb improve <chapter_number> [humor|clarity|consistency]'
    end

  when 'regenerate'
    chapter_num = ARGV[1]&.to_i

    if chapter_num&.positive?
      generator.regenerate_chapter(chapter_num)
    else
      puts 'Usage: ruby generate_chapter.rb regenerate <chapter_number>'
    end

  when 'prompt'
    chapter_num = ARGV[1]&.to_i

    if chapter_num&.positive?
      generator.regenerate_prompt(chapter_num)
    else
      puts 'Usage: ruby generate_chapter.rb prompt <chapter_number>'
    end

  else
    puts 'One Review Man - Chapter Generator'
    puts ''
    puts 'Usage:'
    puts '  ruby generate_chapter.rb [next|generate]     # Generate next chapter'
    puts '  ruby generate_chapter.rb next --auto         # Generate without prompts'
    puts '  ruby generate_chapter.rb improve <num> [type] # Improve existing chapter'
    puts '  ruby generate_chapter.rb regenerate <num>    # Regenerate chapter with AI'
    puts '  ruby generate_chapter.rb prompt <num>        # Show prompt for chapter'
    puts ''
    puts 'Improvement types: humor, clarity, consistency'
  end
end
</file>

<file path="scripts/manage_characters.rb">
#!/usr/bin/env ruby
# frozen_string_literal: true

require 'yaml'
require 'date'
require_relative 'book_utils'
require_relative 'llm_service'

class CharacterManager
  include BookUtils

  def initialize
    # Always work with English
    @characters = load_characters
    @book_data = load_book_data
    @llm_service = LLMService.new
  end

  def generate_character(character_type = 'side')
    # Handle special character types
    case character_type.downcase
    when 'protagonist'
      return generate_one_review_man
    when 'disciple'
      return generate_ai_disciple
    end

    puts "ü§ñ Generating new #{character_type} character with AI..."

    prompt = build_character_generation_prompt(character_type)

    begin
      character_data = @llm_service.generate_character(prompt)

      if character_data && character_data['name']
        # Clean up and validate character data
        processed_character = process_generated_character(character_data)

        success = add_character(processed_character)

        if success
          puts "‚úÖ Character '#{processed_character['name']}' generated and created successfully!"
          return processed_character
        end
      else
        puts '‚ùå Failed to generate valid character data'
        puts('Character data: ', character_data.inspect)
      end
    rescue LLMService::LLMError => e
      puts "‚ùå Character generation failed: #{e.message}"
      puts "Consider creating a character manually with 'ruby manage_characters.rb add'"
    end

    nil
  end

  def generate_one_review_man
    puts 'ü§ñ Generating One Review Man - the ultimate programmer...'

    # Check if One Review Man already exists
    if character_exists?('one_review_man')
      puts "One Review Man already exists! Use 'list' to see existing characters."
      return nil
    end

    # Build specific prompt for One Review Man
    prompt = build_one_review_man_prompt

    begin
      character_data = @llm_service.generate_character(prompt)

      if character_data && character_data['name']
        # Clean up and validate character data
        processed_character = process_generated_character(character_data)

        # Ensure canonical name and first appearance
        processed_character['name'] = 'One Review Man'
        processed_character['first_appearance'] = 'Chapter 1'

        success = add_character(processed_character)

        if success
          puts '‚úÖ One Review Man has been created! The ultimate programmer has joined the story.'
          return processed_character
        end
      else
        puts '‚ùå Failed to generate valid character data for One Review Man'
        puts('Character data: ', character_data.inspect)
      end
    rescue LLMService::LLMError => e
      puts "‚ùå One Review Man generation failed: #{e.message}"
      puts 'Consider creating the character manually'
    end

    nil
  end

  def generate_ai_disciple
    puts "ü§ñ Generating AI-Enhanced Disciple - One Review Man's devoted student..."

    # Check if the disciple already exists
    if character_exists?('ai_enhanced_disciple')
      puts "AI-Enhanced Disciple already exists! Use 'list' to see existing characters."
      return nil
    end

    # Build specific prompt for AI-Enhanced Disciple
    prompt = build_ai_disciple_prompt

    begin
      character_data = @llm_service.generate_character(prompt)

      if character_data && character_data['name']
        # Clean up and validate character data
        processed_character = process_generated_character(character_data)

        # Ensure canonical name and first appearance
        processed_character['name'] = 'AI-Enhanced Disciple'
        processed_character['first_appearance'] = 'Chapter 1'
        processed_character['relationships'] = ['One Review Man (master/mentor)']

        success = add_character(processed_character)

        if success
          puts '‚úÖ AI-Enhanced Disciple has been created! One Review Man now has a devoted student.'
          return processed_character
        end
      else
        puts '‚ùå Failed to generate valid character data for AI-Enhanced Disciple'
        puts('Character data: ', character_data.inspect)
      end
    rescue LLMService::LLMError => e
      puts "‚ùå AI-Enhanced Disciple generation failed: #{e.message}"
      puts 'Consider creating the character manually'
    end

    nil
  end

  def list_characters
    puts "\n=== Characters ==="
    @characters['characters'].each do |slug, char|
      puts "#{char['name']} (#{slug})"
      puts "  Description: #{char['description']}"
      puts "  First appearance: #{char['first_appearance'] || 'Not yet appeared'}"
      puts "  Traits: #{char['personality_traits']&.join(', ') || 'None listed'}"
      puts "  Skills: #{char['programming_skills'] || 'General programming'}"
      puts ''
    end
  end

  private

  def add_character(character_data)
    slug = slugify(character_data['name'])

    if character_exists?(slug)
      puts "Character '#{character_data['name']}' already exists!"
      return false
    end

    # Add to characters data
    @characters['characters'][slug] = character_data.merge({
                                                             'slug' => slug,
                                                             'created_date' => Date.today.to_s
                                                           })

    # Create character page
    create_character_page(slug, character_data)

    # Update metadata
    @book_data['status']['characters_created'] += 1

    # Save changes
    save_characters(@characters)
    save_book_data(@book_data)

    puts "Character '#{character_data['name']}' created successfully!"
    true
  end

  def character_exists?(slug)
    @characters['characters'].key?(slug)
  end

  def build_character_generation_prompt(character_type)
    template_file = 'scripts/prompts/character_prompts.txt'
    raise "Prompt template not found at #{template_file}" unless File.exist?(template_file)

    template = File.read(template_file)

    # Safely handle characters data
    characters_hash = @characters['characters'] || {}
    existing_chars_context = characters_hash.map do |_slug, char|
      "#{char['name']}: #{char['description']}"
    end.join("\n")

    character_type_mapping = {
      'main' => 'MAIN CHARACTERS (Protagonists)',
      'hero' => 'HERO CHARACTERS (Fellow Programmers)',
      'villain' => 'VILLAIN CHARACTERS (Bad Coders/Practices)',
      'side' => 'SIDE CHARACTERS (Workplace NPCs)',
      'mentor' => 'MENTOR CHARACTERS (Senior Figures)'
    }

    mapped_type = character_type_mapping[character_type.downcase]
    raise "Character type not found in mapping: #{character_type_mapping}" unless mapped_type

    template
      .gsub('{CHARACTER_TYPE}', mapped_type)
      .gsub('{EXISTING_CHARACTERS_CONTEXT}', existing_chars_context.empty? ? 'No existing characters yet.' : "Existing characters:\n#{existing_chars_context}")
      .gsub('{SPECIAL_REQUIREMENTS}', "Create a #{character_type} character that fits the One Review Man universe.")
  end

  def build_one_review_man_prompt
    template_file = 'scripts/prompts/one_review_man_prompt.txt'
    raise "Prompt template not found at #{template_file}" unless File.exist?(template_file)

    template = File.read(template_file)
    existing_chars_context = get_existing_characters_context

    template.gsub('{EXISTING_CHARACTERS_CONTEXT}', existing_chars_context.empty? ? 'No existing characters yet.' : existing_chars_context)
  end

  def build_ai_disciple_prompt
    template_file = 'scripts/prompts/ai_disciple_prompt.txt'
    raise "Prompt template not found at #{template_file}" unless File.exist?(template_file)

    template = File.read(template_file)
    existing_chars_context = get_existing_characters_context

    template.gsub('{EXISTING_CHARACTERS_CONTEXT}', existing_chars_context.empty? ? 'No existing characters yet.' : existing_chars_context)
  end

  def get_existing_characters_context
    characters_hash = @characters['characters'] || {}
    characters_hash.map do |_slug, char|
      "#{char['name']}: #{char['description']}"
    end.join("\n")
  end

  def process_generated_character(character_data)
    # Ensure required fields and clean up data
    processed = {
      'name' => character_data['name']&.strip,
      'description' => character_data['description']&.strip,
      'personality_traits' => extract_traits(character_data),
      'programming_skills' => character_data['programming_skills']&.strip || 'General programming',
      'catchphrase' => character_data['catchphrase']&.strip,
      'backstory' => character_data['backstory']&.strip,
      'quirks' => character_data['quirks']&.strip
    }.compact # Remove nil/empty values

    # Ensure name exists
    processed['name'] = 'Generated Character' unless processed['name'] && !processed['name'].empty?

    # Ensure description exists
    unless processed['description'] && !processed['description'].empty?
      processed['description'] = 'A programmer with unique abilities'
    end

    processed
  end

  def extract_traits(character_data)
    traits = character_data['personality_traits'] || character_data['traits']

    case traits
    when Array
      traits.map(&:strip).reject(&:empty?)
    when String
      traits.split(',').map(&:strip).reject(&:empty?)
    else
      []
    end
  end

  def create_character_page(slug, character_data)
    filename = "_characters/#{slug}.md"

    # Generate proper permalink for Jekyll Polyglot (use dashes, not underscores)
    permalink_slug = slug.gsub('_', '-')
    permalink = "/characters/#{permalink_slug}/"

    front_matter = {
      'layout' => 'character',
      'name' => character_data['name'],
      'slug' => slug,
      'description' => character_data['description'],
      'personality_traits' => character_data['personality_traits'] || [],
      'programming_skills' => character_data['programming_skills'],
      'first_appearance' => character_data['first_appearance'],
      'relationships' => character_data['relationships'] || [],
      'permalink' => permalink,
      'created_date' => Date.today.to_s,
      'lang' => 'en'
    }

    File.open(filename, 'w') do |file|
      file.puts '---'
      file.puts front_matter.to_yaml.lines[1..]
      file.puts '---'
      file.puts ''

      file.puts "## About #{character_data['name']}"
      file.puts ''
      file.puts character_data['description']
      file.puts ''

      if character_data['programming_skills']
        file.puts '## Programming Skills'
        file.puts ''
        file.puts character_data['programming_skills']
        file.puts ''
      end

      if character_data['backstory']
        file.puts '## Backstory'
        file.puts ''
        file.puts character_data['backstory']
        file.puts ''
      end

      if character_data['quirks']
        file.puts '## Notable Quirks'
        file.puts ''
        file.puts character_data['quirks']
        file.puts ''
      end

      if character_data['catchphrase']
        file.puts '## Catchphrase'
        file.puts ''
        file.puts "> \"#{character_data['catchphrase']}\""
        file.puts ''
      end

      file.puts '## Appearances'
      file.puts ''
      file.puts "First appeared in: #{character_data['first_appearance'] || 'To be determined'}"
      file.puts ''
      file.puts '<!-- Chapter appearances will be tracked automatically -->'
    end
  end

  def slugify(name)
    name.downcase.gsub(/[^a-z0-9\u0430-\u044f]+/, '_').gsub(/^_+|_+$/, '')
  end
end

# Command line interface
if __FILE__ == $PROGRAM_NAME
  manager = CharacterManager.new

  case ARGV[0]
  when 'generate'
    character_type = ARGV[1] || 'side'
    manager.generate_character(character_type)

  when 'protagonist'
    manager.generate_one_review_man

  when 'disciple'
    manager.generate_ai_disciple

  when 'list'
    manager.list_characters

  else
    puts 'One Review Man - Character Manager'
    puts ''
    puts 'Usage:'
    puts '  ruby manage_characters.rb generate [type]  # Generate character with AI'
    puts '  ruby manage_characters.rb protagonist      # Generate One Review Man himself'
    puts '  ruby manage_characters.rb disciple        # Generate AI-Enhanced Disciple'
    puts '  ruby manage_characters.rb list             # List all characters'
    puts ''
    puts 'Character types: main, hero, villain, side, mentor'
    puts ''
    puts 'Examples:'
    puts '  ruby manage_characters.rb protagonist      # Generate One Review Man (main protagonist)'
    puts '  ruby manage_characters.rb disciple        # Generate AI-Enhanced Disciple (Genos equivalent)'
    puts '  ruby manage_characters.rb generate main    # Generate a main character/protagonist'
    puts '  ruby manage_characters.rb generate hero    # Generate a hero character'
    puts '  ruby manage_characters.rb list             # Show all characters'
  end
end
</file>

</files>
